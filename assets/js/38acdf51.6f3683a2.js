"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6249],{4484:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var n=a(7462),l=(a(7294),a(3905)),i=a(6340);const r={},o="Day 19: Linen Layout",s={unversionedId:"2024/puzzles/day19",id:"2024/puzzles/day19",title:"Day 19: Linen Layout",description:"by Pawe\u0142 Cembaluk",source:"@site/target/mdoc/2024/puzzles/day19.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day19",permalink:"/scala-advent-of-code/2024/puzzles/day19",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day19.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 18: RAM Run",permalink:"/scala-advent-of-code/2024/puzzles/day18"},next:{title:"Day 20: Race Condition",permalink:"/scala-advent-of-code/2024/puzzles/day20"}},p={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Parsing the input",id:"parsing-the-input",level:3},{value:"Solution",id:"solution",level:3},{value:"Part 2",id:"part-2",level:2},{value:"Final code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1-1",level:3},{value:"Part 2",id:"part-2-1",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:u};function c(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-19-linen-layout"},"Day 19: Linen Layout"),(0,l.kt)("p",null,"by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/19"},"https://adventofcode.com/2024/day/19")),(0,l.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,l.kt)("p",null,"The puzzle involves arranging towels to match specified patterns. Each towel has a predefined stripe sequence, and the\ntask is to determine:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Part 1"),": How many patterns can be formed using the available towels?"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Part 2"),": For each pattern, how many unique ways exist to form it using the towels?")),(0,l.kt)("p",null,"The solution leverages regular expressions to validate patterns in Part 1 and employs recursion with memoization for\nefficient counting in Part 2."),(0,l.kt)("h2",{id:"part-1"},"Part 1"),(0,l.kt)("h3",{id:"parsing-the-input"},"Parsing the input"),(0,l.kt)("p",null,"The input consists of two sections:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Towels"),": A comma-separated list of towels (e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"r, wr, b, g"),")."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Desired Patterns"),": A list of patterns to match, each on a new line.")),(0,l.kt)("p",null,"To parse the input, we split it into two parts: towels and desired patterns. Towels are extracted as a comma-separated\nlist, while patterns are read line by line after a blank line. We also introduce type aliases ",(0,l.kt)("inlineCode",{parentName:"p"},"Towel")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Pattern")," for\nclarity in representing these inputs."),(0,l.kt)("p",null,"Here\u2019s the code for parsing:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'type Towel = String\ntype Pattern = String\n\ndef parse(input: String): (List[Towel], List[Pattern]) =\n  val Array(towelsString, patternsString) = input.split("\\n\\n")\n  val towels = towelsString.split(", ").toList\n  val patterns = patternsString.split("\\n").toList\n  (towels, patterns)\n')),(0,l.kt)("h3",{id:"solution"},"Solution"),(0,l.kt)("p",null,"To determine if a pattern can be formed, we use a regular expression. While this could be done manually by checking\ncombinations, the tools in the standard library make it exceptionally easy. The regex matches sequences formed by\nrepeating any combination of the available towels:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def isPossible(towels: List[Towel])(pattern: Pattern): Boolean =\n  val regex = towels.mkString("^(", "|", ")*$").r\n  regex.matches(pattern)\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},'towels.mkString("^(", "|", ")*$")')," builds a regex like ",(0,l.kt)("inlineCode",{parentName:"p"},"^(r|wr|b|g)*$"),". Here\u2019s how it works:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"^"),": Ensures the match starts at the beginning of the string."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(")," and ",(0,l.kt)("inlineCode",{parentName:"li"},")"),": Groups the towel patterns so they can be alternated."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"|"),": Acts as a logical OR between different towels."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*"),": Matches zero or more repetitions of the group."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"$"),": Ensures the match ends at the string\u2019s end.")),(0,l.kt)("p",null,"This approach is simplified because we know the towels contain only letters. If the input could be any string, we would\nneed to use ",(0,l.kt)("inlineCode",{parentName:"p"},"Regex.quote")," to handle special characters properly."),(0,l.kt)("p",null,"Finally, using the ",(0,l.kt)("inlineCode",{parentName:"p"},"isPossible")," function, we filter and count the patterns that can be formed:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part1(input: String): Int =\n  val (towels, patterns) = parse(input)\n  patterns.count(isPossible(towels))\n")),(0,l.kt)("h2",{id:"part-2"},"Part 2"),(0,l.kt)("p",null,"To count all unique ways to form a pattern, we start with a base algorithm that recursively matches towels from the\nstart of the pattern. For each match, we remove the matched part and solve for the remaining pattern. This ensures we\nexplore all possible combinations of towels. Since the numbers involved can grow significantly, we use ",(0,l.kt)("inlineCode",{parentName:"p"},"Long")," to handle\nthe large values resulting from these calculations."),(0,l.kt)("p",null,"Here\u2019s the code for the base algorithm:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def countOptions(towels: List[Towel], pattern: Pattern): Long =\n  towels\n    .collect {\n      case towel if pattern.startsWith(towel) => // Match the towel at the beginning of the pattern\n        pattern.drop(towel.length) // Remove the matched towel\n    }\n    .map { remainingPattern =>\n      if (remainingPattern.isEmpty) 1 // The pattern is fully matched\n      else countOptions(towels, remainingPattern) // Recursively solve the remaining pattern\n    }\n    .sum // Sum the results for all possible towels\n")),(0,l.kt)("p",null,"That's not enough though. The above algorithm will repeatedly solve the same sub-patterns quite often, making it\ninefficient. To optimize it, we introduce memoization. Memoization stores results for previously solved sub-patterns,\neliminating redundant computations. We also pass all the patterns to the function to fully utilize the memoization\ncache."),(0,l.kt)("p",null,"Here's the code with additional cache for already calculated sub-patterns:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def countOptions(towels: List[Towel], patterns: List[Pattern]): Long =\n  val cache = mutable.Map.empty[Pattern, Long]\n\n  def loop(pattern: Pattern): Long =\n    cache.getOrElseUpdate( // Get the result from the cache\n      pattern,\n      // Calculate the result if it's not in the cache\n      towels\n        .collect {\n          case towel if pattern.startsWith(towel) => // Match the towel at the beginning of the pattern\n            pattern.drop(towel.length) // Remove the matched towel\n        }\n        .map { remainingPattern =>\n          if (remainingPattern.isEmpty) 1 // The pattern is fully matched\n          else loop(remainingPattern) // Recursively solve the remaining pattern\n        }\n        .sum // Sum the results for all possible towels\n    )\n\n  patterns.map(loop).sum // Sum the results for all patterns\n")),(0,l.kt)("p",null,"Now, we just have to pass the input to the ",(0,l.kt)("inlineCode",{parentName:"p"},"countOptions")," function to get the final result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part2(input: String): Long =\n  val (towels, patterns) = parse(input)\n  countOptions(towels, patterns)\n")),(0,l.kt)("h2",{id:"final-code"},"Final code"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'type Towel = String\ntype Pattern = String\n\ndef parse(input: String): (List[Towel], List[Pattern]) =\n  val Array(towelsString, patternsString) = input.split("\\n\\n")\n  val towels = towelsString.split(", ").toList\n  val patterns = patternsString.split("\\n").toList\n  (towels, patterns)\n\ndef part1(input: String): Int =\n  val (towels, patterns) = parse(input)\n  val possiblePatterns = patterns.filter(isPossible(towels))\n  possiblePatterns.size\n\ndef isPossible(towels: List[Towel])(pattern: Pattern): Boolean =\n  val regex = towels.mkString("^(", "|", ")*$").r\n  regex.matches(pattern)\n\ndef part2(input: String): Long =\n  val (towels, patterns) = parse(input)\n  countOptions(towels, patterns)\n\ndef countOptions(towels: List[Towel], patterns: List[Pattern]): Long =\n  val cache = mutable.Map.empty[Pattern, Long]\n\n  def loop(pattern: Pattern): Long =\n    cache.getOrElseUpdate(\n      pattern,\n      towels\n        .collect {\n          case towel if pattern.startsWith(towel) =>\n            pattern.drop(towel.length)\n        }\n        .map { remainingPattern =>\n          if (remainingPattern.isEmpty) 1\n          else loop(remainingPattern)\n        }\n        .sum\n    )\n\n  patterns.map(loop).sum\n')),(0,l.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,l.kt)("h3",{id:"part-1-1"},"Part 1"),(0,l.kt)(i.Z,{puzzle:"day19-part1",year:"2024",mdxType:"Solver"}),(0,l.kt)("h3",{id:"part-2-1"},"Part 2"),(0,l.kt)(i.Z,{puzzle:"day19-part2",year:"2024",mdxType:"Solver"}),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D19T2.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day19.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day19/src/main/scala/Solution.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")," "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day19.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day19.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2024/day19.html"},"Writeup")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day19/linen-layout.sc"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day19"},"Solution")," by ",(0,l.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,l.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);