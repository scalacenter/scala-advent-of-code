"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8801],{1073:(a,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=e(7462),i=(e(7294),e(3905));e(6340);const o={},r="Day 8: Resonant Collinearity",l={unversionedId:"2024/puzzles/day08",id:"2024/puzzles/day08",title:"Day 8: Resonant Collinearity",description:"by @merlinorg",source:"@site/target/mdoc/2024/puzzles/day08.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day08",permalink:"/scala-advent-of-code/2024/puzzles/day08",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day08.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 7: Bridge Repair",permalink:"/scala-advent-of-code/2024/puzzles/day07"},next:{title:"Day 9: Disk Fragmenter",permalink:"/scala-advent-of-code/2024/puzzles/day09"}},s={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Data model",id:"data-model",level:3},{value:"Antenna map",id:"antenna-map",level:4},{value:"Location",id:"location",level:4},{value:"Parsing",id:"parsing",level:4},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:c};function p(a){let{components:t,...e}=a;return(0,i.kt)("wrapper",(0,n.Z)({},h,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-8-resonant-collinearity"},"Day 8: Resonant Collinearity"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/8"},"https://adventofcode.com/2024/day/8")),(0,i.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse the map to identify the locations of all the antennae,\ngrouped by their frequency."),(0,i.kt)("li",{parentName:"ol"},"Find all the antinode locations within the map boundary."),(0,i.kt)("li",{parentName:"ol"},"Count the number of distinct antinodes.")),(0,i.kt)("h3",{id:"data-model"},"Data model"),(0,i.kt)("p",null,"First, we'll define some case classes to represent the antenna map.\nWe could use tuples, but the named classes help readability."),(0,i.kt)("h4",{id:"antenna-map"},"Antenna map"),(0,i.kt)("p",null,"An antenna map contains the width and height of the map, along with\na sequence of sequences of antenna locations. Each sequence of antenna\nlocations corresponds to a particular frequency (i.e. a particular\nletter or digit on the map.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class AntennaMap(\n  width: Int,\n  height: Int,\n  antennaGroups: Iterable[Seq[Location]],\n)\n")),(0,i.kt)("h4",{id:"location"},"Location"),(0,i.kt)("p",null,"A location is an ",(0,i.kt)("em",{parentName:"p"},"x, y")," pair along with some helpers for location\narithmetic and range checking."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Location(x: Int, y: Int):\n  def -(other: Location): Vec          = Vec(x - other.x, y - other.y)\n  def +(vec: Vec): Location            = Location(x + vec.dx, y + vec.dy)\n  def within(map: AntennaMap): Boolean = x >= 0 && x < map.width && y >= 0 && y < map.height\nend Location\n\ncase class Vec(dx: Int, dy: Int)\n")),(0,i.kt)("h4",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"To parse the map, we iterate through each line of the input and each\ncharacter of each line, emitting an antenna tuple (the character and\nlocation) if the character is alphanumeric. We then return a board\ncontaining the map dimensions and the antennae, grouped by their\nfrequency (the character)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def parse(input: String): AntennaMap =\n  val lines = input.linesIterator.toSeq\n\n  val antennae: Seq[(Char, Location)] = for\n    (line, y) <- lines.zipWithIndex\n    (char, x) <- line.zipWithIndex\n    if Character.isLetterOrDigit(char)\n  yield char -> Location(x, y)\n\n  AntennaMap(\n    lines.head.length,\n    lines.size,\n    antennae.groupMap(_._1)(_._2).values\n  )\nend parse\n")),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"For part 1, we take each pair of antennae of a given frequency and locate\ntheir antinodes. We then count the number of distinct locations within the\nmap area."),(0,i.kt)("p",null,"According to the puzzle, the antinodes are collinear with each pair of\nsame-frequency antennae, but located at twice the distance from one antenna\nas the other. Vector algebra tells us that the two antinodes of antennae A and\nB lie at A + B\u2192A and B + A\u2192B, where B\u2192A is the vector from B to A, because\n|A \u2192 (B + A\u2192B)| = |A\u2192B| + |A\u2192B| = 2|A\u2192B|."),(0,i.kt)("p",null,"The code thus loops through each antenna group, loops through each combination\nof two antennae of a given frequency, computes the two antinodes, tests that\nthey are within the map, and then counts the distinct results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part1(input: String): String =\n  val map = parse(input)\n\n  val antinodes: Iterable[Location] = for\n    antennaGroup     <- map.antennaGroups\n    case a +: b +: _ <- antennaGroup.combinations(2)\n    antinode         <- Seq(a + (a - b), b + (b - a))\n    if antinode.within(map)\n  yield antinode\n\n  antinodes.toSet.size.toString\nend part1\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Part 2 is very similar to part 1, but instead of there being only two antinodes,\nthe antinodes occur at any location that is a whole multiple of the distance\nbetween the antennae. That is, the antinodes lie at A + n(B\u2192A). We can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator.iterate")," to generate the infinite series of these locations and then\njust take while the location is within the map."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part2(input: String): String =\n  val map = parse(input)\n\n  val antinodes: Iterable[Location] = for\n    antennaGroup     <- map.antennaGroups\n    case a +: b +: _ <- antennaGroup.combinations(2)\n    antinode         <- Iterator.iterate(a)(_ + (a - b)).takeWhile(_.within(map)) ++\n                          Iterator.iterate(b)(_ + (b - a)).takeWhile(_.within(map))\n  yield antinode\n\n  antinodes.toSet.size.toString\nend part2\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D8T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day8/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/fthomas/aoc24/blob/main/src/main/scala/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/fthomas"},"Frank Thomas")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/profunctor-optics/advent-2024/blob/main/src/main/scala/advent2024/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/joroKr21"},"Georgi Krastev")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day8.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day8.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DayEight.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/08/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day08/resonant-collinearity.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/main/src/aoc2024/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day8.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer/adventofcode2024/blob/e163baeaedcd90732b5e19f578a2faadeb1ef872/src/main/scala/day8.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/itsjoeoui/aoc2024/blob/main/src/day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/itsjoeoui"},"itsjoeoui")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day8"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}p.isMDXComponent=!0}}]);