"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5779],{3002:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));a(6340);const l={},i="Day 5: Cafeteria",o={unversionedId:"2025/puzzles/day05",id:"2025/puzzles/day05",title:"Day 5: Cafeteria",description:"by Bulby",source:"@site/target/mdoc/2025/puzzles/day05.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day05",permalink:"/scala-advent-of-code/2025/puzzles/day05",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day05.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 4: Printing Department",permalink:"/scala-advent-of-code/2025/puzzles/day04"},next:{title:"Day 6: Trash Compactor",permalink:"/scala-advent-of-code/2025/puzzles/day06"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"day-5-cafeteria"},"Day 5: Cafeteria"),(0,r.kt)("p",null,"by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,r.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/5"},"https://adventofcode.com/2025/day/5")),(0,r.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Parse input into list of ranges and list of ingredient IDs"),(0,r.kt)("li",{parentName:"ul"},"For part 1, count the amount of ingredients that are fresh"),(0,r.kt)("li",{parentName:"ul"},"For part 2, find the total size of all of the ranges combined",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This will require special handling to prevent overlap!")))),(0,r.kt)("h2",{id:"parsing"},"Parsing"),(0,r.kt)("p",null,"We'll need to end up doing more fancy stuff with our range type, so let's define it as a case class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final case class LRange(start: Long, end: Long)\n")),(0,r.kt)("p",null,"We can't use ",(0,r.kt)("inlineCode",{parentName:"p"},"NumericRange")," because getting the size returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", and it will throw for ranges bigger than ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.MaxValue"),".\nWe have to handle ranges with a size greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"Int.MaxValue"),", so we'll need to roll our own here."),(0,r.kt)("p",null,"Let's define our parsed input as a tuple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"type Input = (List[LRange], List[Long])\n")),(0,r.kt)("p",null,"Parsing isn't that bad then. Note that here I'm using ",(0,r.kt)("inlineCode",{parentName:"p"},"runtimeChecked"),", which isn't stable yet.\nIt will end up being stable when Scala 3.8.0 comes out, but if you're following along at home and don't want\nto add ",(0,r.kt)("inlineCode",{parentName:"p"},"@experimental")," to everything, you can replace it with ",(0,r.kt)("inlineCode",{parentName:"p"},": @unchecked"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(str: String): Input =\n  val Array(ranges, ings) = str.split("\\n\\n").runtimeChecked\n  (\n    ranges.linesIterator.map:\n      case s"$s-$e" => LRange(s.toLong, e.toLong)\n    .toList,\n    ings.linesIterator.map(_.toLong).toList\n  )\n')),(0,r.kt)("h2",{id:"part-1"},"Part 1"),(0,r.kt)("p",null,"We need to see if a range contains an ingredient, so let's add a method to ",(0,r.kt)("inlineCode",{parentName:"p"},"LRange"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final case class LRange(start: Long, end: Long):\n  def contains(n: Long): Boolean = n >= start && n <= end\n")),(0,r.kt)("p",null,"Then we can easily do part 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n  val (ranges, ingredients) = parse(input)\n  ingredients.count(ing => ranges.exists(_.contains(ing))).toLong\n")),(0,r.kt)("h2",{id:"part-2"},"Part 2"),(0,r.kt)("p",null,"Part 2 is a lot more complicated, but I've done ",(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2021/day/22"},"much worse"),", so it wasn't too bad."),(0,r.kt)("p",null,"My common library has implementations for ranges that can intersect and subtract each other, but I'll reimplement them here\njust for completeness."),(0,r.kt)("p",null,"We'll need to add a way to count the amount of values in a range:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final case class LRange(start: Long, end: Long):\n  // ...\n  def size: Long = end - start + 1\n")),(0,r.kt)("p",null,"Alright, now the hard part: intersection and difference.\nWe'll need to add a couple methods to ",(0,r.kt)("inlineCode",{parentName:"p"},"LRange")," to handle intersection and difference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"final case class LRange(start: Long, end: Long):\n")),(0,r.kt)("p",null,"For intersection, there are more or less 4 cases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Overlaps on the left edge"),(0,r.kt)("li",{parentName:"ul"},"Overlaps on the right edge"),(0,r.kt)("li",{parentName:"ul"},"Overlaps internally"),(0,r.kt)("li",{parentName:"ul"},"Overlaps entirely")),(0,r.kt)("p",null,"Let's walk through each case."),(0,r.kt)("p",null,"When we overlap on the left edge, it will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"   *--------* - Us\n*-------*     - Them\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Our start >= their start, <= their end"),(0,r.kt)("li",{parentName:"ul"},"Our end >= their start, >= their end")),(0,r.kt)("p",null,"When we overlap on the right edge, it will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"*-------*     - Us\n   *--------* - Them\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Our start <= their start, <= their end"),(0,r.kt)("li",{parentName:"ul"},"Our end >= their start, <= their end")),(0,r.kt)("p",null,"When we overlap interally, it will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"*--------------* - Us\n    *-------*    - Them\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Our start <= their start, <= their end"),(0,r.kt)("li",{parentName:"ul"},"Our end >= their start, >= their end")),(0,r.kt)("p",null,"When we are entirely overlapped, it will look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    *-------*    - Us\n*--------------* - Them\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Our start >= their start, <= their end"),(0,r.kt)("li",{parentName:"ul"},"Our end >= their start, <= their end")),(0,r.kt)("p",null,"In all cases, our start is <= their end, and our end is >= their start.\nWe can also observe that to get the overlap, we take the maximum start, and the minimum end."),(0,r.kt)("p",null,"So let's add that intersect method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  infix def intersect\n    (\n      t: LRange\n    ): Option[LRange] =\n    Option.when(end >= t.start && start <= t.end):\n      LRange(start max t.start, end min t.end)\n")),(0,r.kt)("p",null,"We needed that intersect to implement difference. The intersect will clamp any points that go outside our bound to\nour edge, meaning we can compare easier."),(0,r.kt)("p",null,"We can do simple math to make the set - we find the points before and after the hole. If we didn't intersect at all,\nthen we can just return a singleton set with ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  infix def -\n    (\n      that: LRange\n    ): Set[LRange] =\n    this intersect that match\n      case Some(hole) =>\n        var daSet = Set.empty[LRange]\n        // if start == hole.start then there won't be any points left before the hole starts\n        if start != hole.start then daSet += LRange(start, hole.start - 1)\n        // if end == hole.end then there won't be any points left after the hole ends\n        if end != hole.end then daSet += LRange(hole.end + 1, end)\n        daSet\n      case _ => Set(this)\n")),(0,r.kt)("p",null,"Now, for part 2, we'll just need to iteratively combine all these ranges."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n  val (ranges, _) = parse(input)\n  val combinedRanges =\n    ranges.foldLeft(Set.empty[LRange]): (acc, range) =>\n      // remove the new range from everything first to prevent overlaps\n      val removed = acc.flatMap(_ - range)\n      // then add it seperately\n      removed + range\n  // iterator to prevent Set from deduplicating our result\n  combinedRanges.iterator.map(_.size).sum\n")),(0,r.kt)("p",null,"It's worth noting that this is similar in concept to a disjoint set, which is a Set of Sets where every Set is disjoint from each other.\nHere, I'm collecting the ranges and making sure that every range is disjoint from each other."),(0,r.kt)("p",null,"Cats collections has an implementation of Disjoint Sets, and it also has an implementation of a Discrete Interval Encoding Tree,\nwhich lets you hold a collection of ranges. This encodes types that are fully ordered, and have a predecessor and successor function.\nThis is true for all integral types. I have a writeup of Day 5 ",(0,r.kt)("a",{parentName:"p",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2025/day05.html"},"implemented entirely using Diet and Range"),"\nfor those curious."),(0,r.kt)("h2",{id:"final-code"},"Final Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'type Input = (List[LRange], List[Long])\n\nfinal case class LRange(start: Long, end: Long):\n  def contains(n: Long): Boolean = n >= start && n <= end\n\n  def size: Long = end - start + 1\n\n  infix def intersect\n    (\n      t: LRange\n    ): Option[LRange] =\n    Option.when(end >= t.start && start <= t.end):\n      LRange(start max t.start, end min t.end)\n\n  infix def -\n    (\n      that: LRange\n    ): Set[LRange] =\n    this intersect that match\n      case Some(hole) =>\n        var daSet = Set.empty[LRange]\n        if start != hole.start then daSet += LRange(start, hole.start - 1)\n        if end != hole.end then daSet += LRange(hole.end + 1, end)\n        daSet\n      case _ => Set(this)\n\ndef parse(str: String): Input =\n  val Array(ranges, ings) = str.split("\\n\\n").runtimeChecked\n  (\n    ranges.linesIterator.map:\n      case s"$s-$e" => LRange(s.toLong, e.toLong)\n    .toList,\n    ings.linesIterator.map(_.toLong).toList\n  )\n\ndef part1(input: String): Long =\n  val (ranges, ingredients) = parse(input)\n  ingredients.count(ing => ranges.exists(_.contains(ing))).toLong\n\ndef part2(input: String): Long =\n  val (ranges, _) = parse(input)\n  val combinedRanges =\n    ranges.foldLeft(Set.empty[LRange]): (acc, range) =>\n      val removed = acc.flatMap(_ - range)\n      removed + range\n  combinedRanges.iterator.map(_.size).sum\n')),(0,r.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/05/solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi"},"nichobi")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2025/day05/DayFive.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day05/src/main/scala/Solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2025/blob/master/src/main/scala/day05/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic/advent-of-code-2025/blob/main/d5/solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic"},"Henryk \u010cesonlovi\u010d")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2025/src/main/scala/Day5.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/counter2015/aoc2025/blob/master/src/main/scala/aoc2025/Day05.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/counter2015"},"counter2015")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day5"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}u.isMDXComponent=!0}}]);