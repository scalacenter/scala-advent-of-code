"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4104],{105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));n(6340);const o={},s="Day 11: Plutonian Pebbles",l={unversionedId:"2024/puzzles/day11",id:"2024/puzzles/day11",title:"Day 11: Plutonian Pebbles",description:"by @bishabosha",source:"@site/target/mdoc/2024/puzzles/day11.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day11",permalink:"/scala-advent-of-code/2024/puzzles/day11",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day11.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 10: Hoof It",permalink:"/scala-advent-of-code/2024/puzzles/day10"},next:{title:"Day 12: Garden Groups",permalink:"/scala-advent-of-code/2024/puzzles/day12"}},r={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-11-plutonian-pebbles"},"Day 11: Plutonian Pebbles"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bishabosha"},"@bishabosha")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/11"},"https://adventofcode.com/2024/day/11")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"This problem is a great fit for Scala's immutable collections library and pattern matching feature."),(0,i.kt)("p",null,"In short, both parts of the problem are identical, asking you to transform a sequence of integers in steps, where in each step each integer is transformed to 1 or 2 new values. You are then tasked to find the total size (i.e. number of stones in the sequence) after a certain number of steps."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For part 1, you are told that order matters, so to find the solution, iterate the row of stones as the rules describe - by in each step replacing the stone in the same position by the new value/values."),(0,i.kt)("li",{parentName:"ul"},"In part 2, it becomes clear that exponential growth when doubling odd-digit-length stones is not sustainable to simulate, so optimise the data representation before iteration.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"As the problem only asks for the number of stones in total, and transformations only consider the current stone (i.e. no look ahead or behind) - the order does not matter in reality."),(0,i.kt)("li",{parentName:"ul"},"With some data analysis, by simulating some iterations, it becomes clear that there are many duplicated stones."),(0,i.kt)("li",{parentName:"ul"},"Therefore for a major space optimisation you only need to consider the frequency of each distinct value.")))),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"The input data is a single line of integer numbers, separated by spaces ",(0,i.kt)("inlineCode",{parentName:"p"},"' '"),". Here is a way to parse that using ",(0,i.kt)("inlineCode",{parentName:"p"},".split")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".toLong")," on strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(input: String): Seq[Long] =\n  input.split(" ").map(_.toLong).toSeq\n')),(0,i.kt)("p",null,"The next part of the problem is to iterate the sequence of stones after a blink:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def blink(stones: Seq[Long]): Seq[Long] =\n  stones.flatMap:\n    case 0                => 1 :: Nil            // x)\n    case EvenDigits(a, b) => a :: b :: Nil       // y)\n    case other            => other * 2024 :: Nil // z)\n")),(0,i.kt)("p",null,"Here you can use ",(0,i.kt)("inlineCode",{parentName:"p"},".flatMap")," on a sequence to transform each element into ",(0,i.kt)("inlineCode",{parentName:"p"},"0 or more"),' elements, which are then concatenated at the end to make a single "flattened" sequence.'),(0,i.kt)("p",null,"The argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," is function where you pattern match on each element as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x)")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", map to ",(0,i.kt)("inlineCode",{parentName:"li"},"[1]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y)")," for a number with even digits, split its digits into two numbers ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b"),", mapping to ",(0,i.kt)("inlineCode",{parentName:"li"},"[a,b]")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"z)")," for any ",(0,i.kt)("inlineCode",{parentName:"li"},"other")," number, map to ",(0,i.kt)("inlineCode",{parentName:"li"},"[other * 2024]"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"To better illustrate how ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap")," works, here is how to duplicate each element:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Seq(1,2,3).flatMap(i => i :: i :: Nil) // for `i`, map to `[i, i]`\n")),(0,i.kt)("p",{parentName:"admonition"},"results in"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Seq(1,1,2,2,3,3)\n"))),(0,i.kt)("p",null,"The code above uses the pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"EvenDigits(a, b)"),", which makes use of a Scala feature called ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/tour/extractor-objects.html"},"extractor objects"),", which lets you define your own custom patterns!"),(0,i.kt)("p",null,"Let's see how it works:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object EvenDigits:\n  def unapply(n: Long): Option[(Long, Long)] =\n    splitDigits(n)\n")),(0,i.kt)("p",null,"so I defined an object ",(0,i.kt)("inlineCode",{parentName:"p"},"EvenDigits")," with an ",(0,i.kt)("inlineCode",{parentName:"p"},"unapply")," method, its parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"(n: Long)")," means it can match on ",(0,i.kt)("inlineCode",{parentName:"p"},"Long")," typed values. The result ",(0,i.kt)("inlineCode",{parentName:"p"},"Option[(Long, Long)]")," means the pattern will either not match, or will match and extract two ",(0,i.kt)("inlineCode",{parentName:"p"},"Long")," values."),(0,i.kt)("p",null,"Its implementation forwards to the ",(0,i.kt)("inlineCode",{parentName:"p"},"splitDigits")," method which you can define as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def splitDigits(n: Long): Option[(Long, Long)] =\n  val digits = Iterator // x)\n    .unfold(n):\n      case 0 => None\n      case i => Some((i % 10, i / 10))\n    .toArray\n  if digits.size % 2 == 0 then // y)\n    val (a, b) = digits.reverse.splitAt(digits.size / 2)\n    Some((mergeDigits(a), mergeDigits(b)))\n  else None\n\ndef mergeDigits(digits: Array[Long]): Long =\n  digits.foldLeft(0L): (acc, digit) =>  // z)\n    acc * 10 + digit\n")),(0,i.kt)("p",null,"The function works in three parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x)")," Convert the input ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," into an array of digits. You can use ",(0,i.kt)("inlineCode",{parentName:"li"},"Iterator.unfold")," for this purpose, where you start with some state, then iterate until either the sequence should stop (return ",(0,i.kt)("inlineCode",{parentName:"li"},"None"),"), or return a pair of the next value of the iterator on the left, and the next state on the right. This will produce the digits in reverse order (starting with unit column on the left)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y)")," If the digits are of even length, then reverse the digits, split in the middle, and merge each part back to a single number"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"z)")," merge the digits back to a single ",(0,i.kt)("inlineCode",{parentName:"li"},"Long"),", with the inverse of the function used to split them.")),(0,i.kt)("p",null,"After defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"blink")," function, you can now run the simulation for the required steps, in this case 25:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val stones0 = parse(input)\n  val stones1 =\n    Iterator\n      .iterate(stones0)(blink)\n      .drop(25)\n      .next\n  stones1.size\n")),(0,i.kt)("p",null,"In the code above, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator.iterate(s)(f)")," method to repeatadly apply a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," to some state ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", returning the next state. In this case use the parsed stones for state, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"blink")," function."),(0,i.kt)("p",null,"Then to get the state after 25 iterations, ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," 25 elements (which includes the initial state, i.e. before any blinks), and take the ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," value. This returns the stone sequence after 25 blinks. Then call ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," to get the number of stones (i.e. the length of the sequence)."),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"All part 2 asked to do is to run the same simulation, but instead for 75 steps. This does not work, likely intentionally, as the required space to represent the sequence grows exponentially, surpassing much more than any conventional home computer."),(0,i.kt)("p",null,"So, somehow you need to compress the space required to represent the sequence. There are a couple of options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a) bin-packing: represent each element by 2 numbers ",(0,i.kt)("inlineCode",{parentName:"li"},"[a1,n1,b1,n2,..."),", i.e. the value, and then the number of times it appears consecutively. This preserves order, but does not work well if duplicates are not close together. (",(0,i.kt)("strong",{parentName:"li"},"such as with this problem"),")"),(0,i.kt)("li",{parentName:"ul"},"b) frequency map: only store the distinct numbers in the sequence, associated to their total count. This is not a sorted representation. ",(0,i.kt)("strong",{parentName:"li"},"HOWEVER")," you actually do not need to consider order, despite what the problem hints at. The answer only requires the total stones in the sequence (i.e. forgets order), and also each stone is transformed independently when there is a blink, so there is no interaction between earlier or later stones.")),(0,i.kt)("p",null,"In this case, I used a frequency map, represented with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Map[Long, Long]"),"."),(0,i.kt)("p",null,"so how does ",(0,i.kt)("inlineCode",{parentName:"p"},"blink")," change?"),(0,i.kt)("p",null,"This time, instead of iterating through each stone in the sequence, you should consider all the stones of a certain value at once. This means you can no longer consider each transformation independently."),(0,i.kt)("p",null,"What you can do instead is for each kind of stone, update the totals that will appear after the blink, and the blink won't be considered done until you process each kind of stone that appeared in the last step."),(0,i.kt)("p",null,"So to accomplish this, use ",(0,i.kt)("inlineCode",{parentName:"p"},"foldLeft"),", which within a single blink step will let us iterate the state of the stones. You can even use the same stones value as the initial state because it is immutable - i.e. each update will create a new copy with the necessary changes. Here is the result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def blinkUnordered(stones: Map[Long, Long]): Map[Long, Long] =\n  stones.foldLeft(stones): (nextStones, stone) =>\n    stone match\n      case (0, n)                      => nextStones.diff(0, -n).diff(1, n)\n      case (old @ EvenDigits(a, b), n) => nextStones.diff(old, -n).diff(a, n).diff(b, n)\n      case (other, n)                  => nextStones.diff(other, -n).diff(other * 2024, n)\n")),(0,i.kt)("p",null,"You still have to define the ",(0,i.kt)("inlineCode",{parentName:"p"},"diff")," method, but to explain what changed since part 1: now consider the key-value association of each stone to the count in the map.\nIn each update, you remove ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," of the old stone, and add ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," of each new stone."),(0,i.kt)("p",null,"You can define ",(0,i.kt)("inlineCode",{parentName:"p"},"diff")," as an extension method on ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (stones: Map[Long, Long])\n  def diff(stone: Long, change: Long): Map[Long, Long] =\n    stones.updatedWith(stone):\n      case None    => Some(change)\n      case Some(n) =>\n        val n0 = n + change\n        if n0 == 0 then None else Some(n0)\n")),(0,i.kt)("p",null,"To put it all together, now you have to convert the parsed stone sequence into a frequency map.\nTo do that, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"groupBy")," function, which buckets values by the result of a function.\nIf you use ",(0,i.kt)("inlineCode",{parentName:"p"},"identity")," as the function, then the values themselves will be the key.\nThe resulting map's values will now be sequences of the same number, so you can transform the map to convert the values to the size (i.e. the frequency)."),(0,i.kt)("p",null,"Then you can again use ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator.iterate")," to evolve the frequency map, now using the ",(0,i.kt)("inlineCode",{parentName:"p"},"blinkUnordered")," function 75 times. The resulting value is still a frequency map, so you can get the total stone count by taking the sum of just the values of the map (i.e. forgetting the keys)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n  val stones0 =\n    parse(input)\n      .groupBy(identity)\n      .map((k, v) => (k, v.size.toLong))\n  val stones1 =\n    Iterator\n      .iterate(stones0)(blinkUnordered)\n      .drop(75)\n      .next\n  stones1.values.sum\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String): Int =\n  val stones0 = parse(input)\n  val stones1 =\n    Iterator\n      .iterate(stones0)(blink)\n      .drop(25)\n      .next\n  stones1.size\n\ndef parse(input: String): Seq[Long] =\n  input.split(" ").map(_.toLong).toSeq\n\ndef blink(stones: Seq[Long]): Seq[Long] =\n  stones.flatMap:\n    case 0                => 1 :: Nil\n    case EvenDigits(a, b) => a :: b :: Nil\n    case other            => other * 2024 :: Nil\n\nobject EvenDigits:\n  def unapply(n: Long): Option[(Long, Long)] =\n    splitDigits(n)\n\ndef splitDigits(n: Long): Option[(Long, Long)] =\n  val digits = Iterator\n    .unfold(n):\n      case 0 => None\n      case i => Some((i % 10, i / 10))\n    .toArray\n  if digits.size % 2 == 0 then\n    val (a, b) = digits.reverse.splitAt(digits.size / 2)\n    Some((mergeDigits(a), mergeDigits(b)))\n  else None\n\ndef mergeDigits(digits: Array[Long]): Long =\n  digits.foldLeft(0L): (acc, digit) =>\n    acc * 10 + digit\n\ndef part2(input: String): Long =\n  val stones0 =\n    parse(input)\n      .groupBy(identity)\n      .map((k, v) => (k, v.size.toLong))\n  val stones1 =\n    Iterator\n      .iterate(stones0)(blinkUnordered)\n      .drop(75)\n      .next\n  stones1.values.sum\n\ndef blinkUnordered(stones: Map[Long, Long]): Map[Long, Long] =\n  stones.foldLeft(stones): (nextStones, stone) =>\n    stone match\n      case (0, n)                      => nextStones.diff(0, -n).diff(1, n)\n      case (old @ EvenDigits(a, b), n) => nextStones.diff(old, -n).diff(a, n).diff(b, n)\n      case (other, n)                  => nextStones.diff(other, -n).diff(other * 2024, n)\n\nextension (stones: Map[Long, Long])\n  def diff(stone: Long, change: Long): Map[Long, Long] =\n    stones.updatedWith(stone):\n      case None    => Some(change)\n      case Some(n) =>\n        val n0 = n + change\n        if n0 == 0 then None else Some(n0)\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D11T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2024/blob/main/2024-day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/11/11.worksheet.sc#L80"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day11/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/11/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/main/src/aoc2024/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day11/plutonian-pebbles.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DayEleven.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day11.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer/adventofcode2024/blob/e163baeaedcd90732b5e19f578a2faadeb1ef872/src/main/scala/day11.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day11"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);