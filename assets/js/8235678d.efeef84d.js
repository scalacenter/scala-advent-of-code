"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7749],{3783:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));t(6340);const l={},o="Day 12: Garden Groups",r={unversionedId:"2024/puzzles/day12",id:"2024/puzzles/day12",title:"Day 12: Garden Groups",description:"by Bulby",source:"@site/target/mdoc/2024/puzzles/day12.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day12",permalink:"/scala-advent-of-code/2024/puzzles/day12",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day12.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 11: Plutonian Pebbles",permalink:"/scala-advent-of-code/2024/puzzles/day11"},next:{title:"Day 13: Claw Contraption",permalink:"/scala-advent-of-code/2024/puzzles/day13"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function u(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-12-garden-groups"},"Day 12: Garden Groups"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/12"},"https://adventofcode.com/2024/day/12")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Convert the input into a vector of strings"),(0,i.kt)("li",{parentName:"ol"},"Get the regions of the input"),(0,i.kt)("li",{parentName:"ol"},"Calculate the price of each region")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"part1"),": Calculate area and perimeter and multiply them together"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"part2"),": Calculate area and number of sides and multiply them together")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},"Sum prices")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"First, let's make a wrapper class for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector[String]")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class PlantMap(plants: Vector[String]) {\n  val height: Int = plants.size\n  val width: Int = plants.head.length\n\n  def apply(x: Int, y: Int): Char = {\n    plants(y)(x)\n  }\n\n  def isDefinedAt(x: Int, y: Int): Boolean = {\n    x >= 0 && x < width && y >= 0 && y < height\n  }\n\n  def get(x: Int, y: Int): Option[Char] = {\n    Option.when(isDefinedAt(x, y))(apply(x, y))\n  }\n}\n")),(0,i.kt)("p",null,"Then, let's parse the input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def parse(str: String): PlantMap = PlantMap(str.linesIterator.toVector)\n")),(0,i.kt)("p",null,"Next, let's get the regions for the input. The puzzle text explictly states that regions that are seperated are different regions, so we have to use flood fill."),(0,i.kt)("p",null,"Here's a simple flood fill implementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"PlantMap"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable as mut\n\ntype Region = Vector[(Int, Int)]\ndef cardinalPositions(x: Int, y: Int): List[(Int, Int)] = {\n  List((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))\n}\n\ncase class PlantMap(plants: Vector[String]) {\n  // ...\n  def floodFill(x: Int, y: Int): Region = {\n    val q = mut.Queue[(Int, Int)]()\n    val char = apply(x, y)\n    val res = mut.ListBuffer[(Int, Int)]()\n    q.addOne((x, y))\n    while (q.nonEmpty) {\n      val n = q.removeHead()\n      if (get(n._1, n._2).contains(char) && !res.contains(n)) {\n        res.prepend(n)\n        q.addAll(cardinalPositions(n._1, n._2))\n      }\n    }\n    res.toVector\n  }\n}\n")),(0,i.kt)("p",null,"This can then be used to get all the regions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class PlantMap(plants: Vector[String]) {\n  def indices: Vector[(Int, Int)] = {\n    (for {\n      y <- 0 until height\n      x <- 0 until width\n    } yield (x, y)).toVector\n  }\n  // ... \n  def regions: List[Region] = {\n    List.unfold[Vector[(Int, Int)], Vector[(Int, Int)]](this.indices) { acc =>\n      acc.headOption.map { head =>\n        val points = floodFill(head._1, head._2)\n        (points, acc.diff(points))\n      }\n    }\n  }\n\n}\n")),(0,i.kt)("p",null,"It's also useful now to define a converter from regions to their own map. This lets us avoid having to know the character."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'extension (region: Region) {\n  def asPlantMap: Vector[String] = {\n    val maxX = region.maxBy(_._1)._1\n    val maxY = region.maxBy(_._2)._2\n    val res = mut.ArrayBuffer.fill(maxY + 1, maxX + 1)(\'.\')\n    region.foreach { (x, y) =>\n      res(y)(x) = \'#\'\n    }\n    PlantMap(res.map(_.mkString("", "", "")).toVector)\n  }\n}\n')),(0,i.kt)("p",null,"Then calculate perimeter of the regions, and solve part 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class PlantMap(plants: Vector[String]) {\n  // ...\n  def optionalCardinalNeighbors(x: Int, y: Int): List[Option[Char]] = {\n    cardinalPositions(x, y).map(get)\n  }\n}\n\nextension (region: Region) {\n  // ...\n  def area: Int = region.size\n  def perimeter: Int = {\n    val regionMap = region.asPlantMap\n    region.map((x, y) => regionMap.optionalCardinalNeighbors(x, y).count(_.forall(_ != '#'))).sum\n  }\n}\n\ndef part1(input: String): Int = {\n  val plants = parse(input)\n\n  plants.regions.map(r => r.area * r.perimeter).sum\n}\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"The hard part of this one is finding out how to efficiently count the number of sides in a region.\nThankfully, there is a fun math fact that can help here: The number of sides in a polygon is equal to the number of corners.\nSo all we have to do is count the number of corners in a region and we will get the number of sides."),(0,i.kt)("p",null,"Finding corners in a 1x1 integer grid is hard, but doubling the size of the grid reduces the amount of cases we have to check."),(0,i.kt)("p",null,"Doubling the grid lets you inspect each corner of each block individually. Through experimentation in a pixel editor,\nyou can find that when using 2x2 squares aligned to a 2x2 grid, there are only a few number of neighbors each pixel can have."),(0,i.kt)("p",null,"Here are those cases outlined:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Not a corner, internal (8)"),(0,i.kt)("li",{parentName:"ul"},"Not a corner, Edge (5)"),(0,i.kt)("li",{parentName:"ul"},'Not a corner, adjacent to "concave-like" corner (6)'),(0,i.kt)("li",{parentName:"ul"},'A corner, "convex-like" (3)'),(0,i.kt)("li",{parentName:"ul"},'A corner, "concave-like" (7)'),(0,i.kt)("li",{parentName:"ul"},'A corner, "convex like" with diagonal neighbor (4)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"..........\n...3553...\n...5886...\n...588763.\n...455553.\n.34.......\n.33.......\n")),(0,i.kt)("p",null,"and the same region with the corners marked:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"..........\n...X##X...\n...####...\n...###X#X.\n...X####X.\n.XX.......\n.XX.......\n")),(0,i.kt)("p",null,"Let's add an extension to double the region:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (region: Region) {\n  // ...\n  def inflate: Region = {\n    region.flatMap((x, y) => List((x * 2, y * 2), (x * 2 + 1, y * 2), (x * 2, y * 2 + 1), (x * 2 + 1, y * 2 + 1)))\n  }\n}\n")),(0,i.kt)("p",null,"Next, let's actually count the sides in the region:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def neighborPositions(ix: Int, iy: Int): List[(Int, Int)] = {\n  (ix - 1 to ix + 1).flatMap { x =>\n    (iy - 1 to iy + 1).flatMap { y =>\n      Option.when(x != ix || y != iy)((x, y))\n    }\n  }.toList\n}\n\ncase class PlantMap(plants: Vector[String]) {\n  def optionalNeighbors(x: Int, y: Int): List[Option[Char]] = {\n    neighborPositions(x, y).map(get)\n  }\n}\n\nextension (region: Region) {\n  // ...\n  def sides: Int = {\n    val bigRegion = region.inflate\n    val regionMap = PlantMap.fromRegion(bigRegion)\n    bigRegion.count { (x, y) =>\n      val neighborCount = regionMap.optionalNeighbors(x, y).count(_.contains('#'))\n      neighborCount match {\n        case 3 | 4 | 7 => true\n        case _ => false\n      }\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Then we can price the regions and solve part 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Int = {\n  val plants = parse(input)\n\n  plants.regions.map(r => r.area * r.sides).sum\n}\n")),(0,i.kt)("p",null,"Final code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.collection.mutable as mut\n\ntype Region = Vector[(Int, Int)]\ndef cardinalPositions(x: Int, y: Int): List[(Int, Int)] = {\n  List((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))\n}\n\ndef neighborPositions(ix: Int, iy: Int): List[(Int, Int)] = {\n  (ix - 1 to ix + 1).flatMap { x =>\n    (iy - 1 to iy + 1).flatMap { y =>\n      Option.when(x != ix || y != iy)((x, y))\n    }\n  }.toList\n}\n\nextension (region: Region) {\n  def asPlantMap: PlantMap = {\n    val maxX = region.maxBy(_._1)._1\n    val maxY = region.maxBy(_._2)._2\n    val res = mut.ArrayBuffer.fill(maxY + 1, maxX + 1)('.')\n    region.foreach { (x, y) =>\n      res(y)(x) = '#'\n    }\n    PlantMap(res.map(_.mkString(\"\", \"\", \"\")).toVector)\n  }\n  \n  def inflate: Region = {\n    region.flatMap((x, y) => List((x * 2, y * 2), (x * 2 + 1, y * 2), (x * 2, y * 2 + 1), (x * 2 + 1, y * 2 + 1)))\n  }\n\n  def sides: Int = {\n    val bigRegion = region.inflate\n    val regionMap = bigRegion.asPlantMap\n    bigRegion.count { (x, y) =>\n      val neighborCount = regionMap.optionalNeighbors(x, y).count(_.contains('#'))\n      neighborCount match {\n        case 3 | 4 | 7 => true\n        case _ => false\n      }\n    }\n  }\n\n  def area: Int = region.size\n  def perimeter: Int = {\n    val regionMap = region.asPlantMap\n    region.map((x, y) => regionMap.optionalCardinalNeighbors(x, y).count(_.forall(_ != '#'))).sum\n  }\n}\n\ncase class PlantMap(plants: Vector[String]) {\n  val height: Int = plants.size\n  val width: Int = plants.head.length\n  // Length should be equal\n  assert(plants.forall(_.length == width))\n\n  def apply(x: Int, y: Int): Char = {\n    plants(y)(x)\n  }\n\n  def get(x: Int, y: Int): Option[Char] = {\n    Option.when(isDefinedAt(x, y))(apply(x, y))\n  }\n\n  def isDefinedAt(x: Int, y: Int): Boolean = {\n    x >= 0 && x < width && y >= 0 && y < height\n  }\n\n  def indices: Vector[(Int, Int)] = {\n    (for {\n      y <- 0 until height\n      x <- 0 until width\n    } yield (x, y)).toVector\n  }\n\n  def optionalCardinalNeighbors(x: Int, y: Int): List[Option[Char]] = {\n    cardinalPositions(x, y).map(get)\n  }\n\n  def optionalNeighbors(x: Int, y: Int): List[Option[Char]] = {\n    neighborPositions(x, y).map(get)\n  }\n  \n  def floodFill(x: Int, y: Int): Region = {\n    val q = mut.Queue[(Int, Int)]()\n    val char = apply(x, y)\n    val res = mut.ListBuffer[(Int, Int)]()\n    q.addOne((x, y))\n    while (q.nonEmpty) {\n      val n = q.removeHead()\n      if (get(n._1, n._2).contains(char) && !res.contains(n)) {\n        res.prepend(n)\n        q.addAll(cardinalPositions(n._1, n._2))\n      }\n    }\n    res.toVector\n  }\n\n  def regions: List[Region] = {\n    List.unfold[Region, Vector[(Int, Int)]](this.indices) { acc =>\n      acc.headOption.map { head =>\n        val points = floodFill(head._1, head._2)\n        (points, acc.diff(points))\n      }\n    }\n  }\n}\n\n\ndef parse(str: String): PlantMap = {\n  PlantMap(str.linesIterator.toVector)\n}\n\ndef part1(input: String): Int = {\n  val plants = parse(input)\n\n  plants.regions.map(r => r.area * r.perimeter).sum\n}\n\ndef part2(input: String): Int = {\n  val plants = parse(input)\n\n  plants.regions.map(r => r.area * r.sides).sum\n}\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D12T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day12/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2024/day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DayTwelve.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/12/12.worksheet.sc#L191"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day12/garden-groups.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day12"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/main/src/aoc2024/Day12.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);