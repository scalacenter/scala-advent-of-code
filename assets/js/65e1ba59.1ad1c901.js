"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[870],{4888:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));a(6340);const l={},r="Day 2: Gift Shop",o={unversionedId:"2025/puzzles/day02",id:"2025/puzzles/day02",title:"Day 2: Gift Shop",description:"by @stewSquared",source:"@site/target/mdoc/2025/puzzles/day02.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day02",permalink:"/scala-advent-of-code/2025/puzzles/day02",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day02.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 1: Secret Entrance",permalink:"/scala-advent-of-code/2025/puzzles/day01"},next:{title:"Day 3: Lobby",permalink:"/scala-advent-of-code/2025/puzzles/day03"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Alternative: Using Regular Expressions",id:"alternative-using-regular-expressions",level:3},{value:"Optimization",id:"optimization",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-2-gift-shop"},"Day 2: Gift Shop"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/stewSquared"},"@stewSquared")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/2"},"https://adventofcode.com/2025/day/2")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"Brute force is sufficient here. We test every number in the ranges for invalid IDs."),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"First we parse the input string. We collect the range strings by splitting on commas, then we can represent each range with an ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/NumericRange$$Inclusive.html"},"Inclusive")," ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/NumericRange.html"},(0,i.kt)("inlineCode",{parentName:"a"},"NumericRange"))," from the standard library:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ranges = input.split(',').map:\n  case s\"$a-$b\" => a.toLong to b.toLong\n")),(0,i.kt)("p",null,"Next, we need to be able to determine if a particular ID is invalid. We can do this by splitting the string representation of the ID into two parts and comparing them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def invalid(id: Long): Boolean =\n  val s = id.toString\n  val (left, right) = s.splitAt(s.length / 2)\n  left == right\n")),(0,i.kt)("p",null,"At this point, we can get every ID from the input by flattening our ranges, then we simply filter with ",(0,i.kt)("inlineCode",{parentName:"p"},"invalid"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ans1 = ranges.iterator.flatten.filter(invalid).sum\n")),(0,i.kt)("p",null,"Note that while ",(0,i.kt)("inlineCode",{parentName:"p"},"Range")," acts like a collection, the individual numbers aren't stored in memory, but when an array of ranges is flattened, it's concretized into an array of numbers, so we first convert with ",(0,i.kt)("inlineCode",{parentName:"p"},".iterator")," to prevent allocating a full ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," of all the IDs being checked."),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"All we need to change is the definition of invalid. Instead of half a string repeated twice, we have a smaller segment of a string repeated multiple times. More specifically, for a proper divisor ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," of the length of the ID ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", the first ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," characters of the ID are repeated ",(0,i.kt)("inlineCode",{parentName:"p"},"n/d")," times."),(0,i.kt)("p",null,"Our ID strings are short enough that we can filter possible divisors with modulo, cases where ",(0,i.kt)("inlineCode",{parentName:"p"},"n % d == 0"),'. We can then check if a segment repeats by "multiplying" the segment, and comparing it to the original ID. Eg., a string like ',(0,i.kt)("inlineCode",{parentName:"p"},'"123"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"123" * 3 == "123123123"'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def invalid2(id: Long) =\n  val s = id.toString\n  val n = s.length\n  val divisors = (1 to n / 2).filter(n % _ == 0)\n  divisors.exists(d => s.take(d) * (n/d) == s)\n")),(0,i.kt)("p",null,"And now we can use the same line from ",(0,i.kt)("inlineCode",{parentName:"p"},"ans1")," with the updated function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val ans2 = ranges.iterator.flatten.filter(invalid2).sum\n")),(0,i.kt)("h3",{id:"alternative-using-regular-expressions"},"Alternative: Using Regular Expressions"),(0,i.kt)("p",null,"We can match any sequence of digits using ",(0,i.kt)("inlineCode",{parentName:"p"},"\\d+"),". If we place that in a parenthesized group, we can reference it with ",(0,i.kt)("inlineCode",{parentName:"p"},"\\1")," to account for repeats. Part 1 looks like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def invalid(id: Long) = """(\\d+)\\1""".r.matches(id.toString)\n')),(0,i.kt)("p",null,"This first matches any sequence of digits, then succeeds if that sequence is followed by itself. For part 2, we repeat the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\1")," match at least once, using ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def invalid2(id: Long) = """(\\d+)\\1+""".r.matches(id.toString)\n')),(0,i.kt)("h3",{id:"optimization"},"Optimization"),(0,i.kt)("p",null,"While a brute force check of each possible ID works for the provided inputs, an input range could very easily represent gigabytes of Longs. Instead, it's possible to generate invalid IDs directly (eg., start with ",(0,i.kt)("inlineCode",{parentName:"p"},"123")," and multiply by ",(0,i.kt)("inlineCode",{parentName:"p"},"1001"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"1001001"),", etc.). In a solution by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/merlinorg/advent-of-code/blob/789cb88de7e09bc36928b87be685cc95b30e9a4a/src/main/scala/year2025/day02.scala#L30-L42"},"such an approach")," drops complexity from ",(0,i.kt)("inlineCode",{parentName:"p"},"O(n)")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"O(sqrt(n))")," for part 1."),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import collection.immutable.NumericRange\n\ndef part1(input: String): Long =\n  ranges(input).iterator.flatten.filter(invalid).sum\n\ndef part2(input: String): Long =\n  ranges(input).iterator.flatten.filter(invalid2).sum\n\ndef ranges(input: String): NumericRange[Long] =\n  input.split(',').map:\n    case s\"$a-$b\" => a.toLong to b.toLong\n\ndef invalid(id: Long): Boolean =\n  val s = id.toString\n  val (left, right) = s.splitAt(s.length / 2)\n  left == right\n\ndef invalid2(id: Long): Boolean =\n  val s = id.toString\n  val n = s.length\n  val divisors = (1 to n / 2).filter(n % _ == 0)\n  divisors.exists(d => s.take(d) * (n/d) == s)\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day02/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2025/blob/main/scala/2025_day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2025/src/main/scala/Day2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/stewSquared/advent-of-code/blob/master/src/main/scala/2025/Day02.worksheet.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/stewSquared"},"Stewart Stewart")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=oo1J4u2zATY&list=PLnP_dObOt-rWB2QisPZ67anfI7CZx3Vsq&t=3577s"},"Live solve recording")," by ",(0,i.kt)("a",{parentName:"li",href:"https://youtube.com/@stewSquared"},"Stewart Stewart")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2025/day02.html"},"Writeup")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/counter2015/aoc2025/blob/master/src/main/scala/aoc2025/Day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/counter2015"},"counter2015")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/johnduffell/aoc-2025/blob/main/src/main/scala/Day2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/johnduffell"},"John Duffell")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2025/blob/master/src/main/scala/day02/Day02.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/02/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2025/day02/DayTwo.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}m.isMDXComponent=!0}}]);