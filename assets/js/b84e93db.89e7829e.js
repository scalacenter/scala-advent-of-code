"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2999],{4410:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var o=a(7462),n=(a(7294),a(3905));a(6340);const i={},r="Day 10: Hoof It",s={unversionedId:"2024/puzzles/day10",id:"2024/puzzles/day10",title:"Day 10: Hoof It",description:"by @SethTisue",source:"@site/target/mdoc/2024/puzzles/day10.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day10",permalink:"/scala-advent-of-code/2024/puzzles/day10",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Disk Fragmenter",permalink:"/scala-advent-of-code/2024/puzzles/day09"},next:{title:"Day 11: Plutonian Pebbles",permalink:"/scala-advent-of-code/2024/puzzles/day11"}},l={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Summary",id:"summary",level:2},{value:"Shared code",id:"shared-code",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:p};function c(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"day-10-hoof-it"},"Day 10: Hoof It"),(0,n.kt)("p",null,"by ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/SethTisue"},"@SethTisue")),(0,n.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/10"},"https://adventofcode.com/2024/day/10")),(0,n.kt)("h2",{id:"summary"},"Summary"),(0,n.kt)("p",null,"Like many Advent of Code puzzles, this is a graph search problem.\nSuch problems are highly amenable to recursive solutions."),(0,n.kt)("p",null,"In large graphs, it may be necessary to memoize intermediate results\nin order to get good performance. But here, it turns out that the\ngraphs are small enough that recursion alone does the job just fine."),(0,n.kt)("h3",{id:"shared-code"},"Shared code"),(0,n.kt)("p",null,"Let's start by representing coordinate pairs:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  type Pos = (Int, Int)\n  extension (pos: Pos)\n    def +(other: Pos): Pos =\n      (pos(0) + other(0), pos(1) + other(1))\n")),(0,n.kt)("p",null,"and the input grid:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  type Topo = Vector[Vector[Int]]\n  extension (topo: Topo)\n    def apply(pos: Pos): Int =\n      topo(pos(0))(pos(1))\n    def inBounds(pos: Pos): Boolean =\n      pos(0) >= 0 && pos(0) < topo.size &&\n      pos(1) >= 0 && pos(1) < topo.head.size\n    def positions =\n      for row <- topo.indices\n          column <- topo.head.indices\n      yield (row, column)\n")),(0,n.kt)("p",null,"So far this is all quite typical code that is usable in many\nAdvent of Code puzzles."),(0,n.kt)("p",null,"Reading the input is typical as well:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  def getInput(name: String): Topo =\n    io.Source.fromResource(name)\n    .getLines\n    .map(_.map(_.asDigit).toVector)\n    .toVector\n")),(0,n.kt)("p",null,'In order to avoid doing coordinate math all the time, let\'s turn the\ngrid into a graph by analyzing which cells are actually connected to\neach other. Each cell can only have a small number of "reachable"\nneighbors -- those neighbors that are exactly 1 higher than us.'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  type Graph = Map[Pos, Set[Pos]]\n\n  def computeGraph(topo: Topo): Graph =\n    def reachableNeighbors(pos: Pos): Set[Pos] =\n      Set((-1, 0), (1, 0), (0, -1), (0, 1))\n      .flatMap: offsets =>\n        Some(pos + offsets)\n        .filter: nextPos =>\n          topo.inBounds(nextPos) && topo(nextPos) == topo(pos) + 1\n    topo.positions\n    .map(pos => pos -> reachableNeighbors(pos))\n    .toMap\n")),(0,n.kt)("p",null,"with this graph structure in hand, we can forget about the grid\nand solve the problem at a higher level of abstraction."),(0,n.kt)("h3",{id:"part-1"},"Part 1"),(0,n.kt)("p",null,"Part 1 is actually more difficult than part 2, in my opinion.  In\nfact, in my first attempt to solve part 1, I accidentally solved part\n2! Once I saw part 2, I had to go back and reconstruct what I had done\nearlier."),(0,n.kt)("p",null,"From a given trailhead, the same summit may be reachable by multiple\nroutes. Therefore, we can't just count routes; we must remember what\nthe destinations are. Hence, the type of the recursive method is\n",(0,n.kt)("inlineCode",{parentName:"p"},"Set[Pos]")," -- the set of summits that are reachable from the current\nposition."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  def solve1(topo: Topo): Int =\n    val graph = computeGraph(topo)\n    def reachableSummits(pos: Pos): Set[Pos] =\n      if topo(pos) == 9\n      then Set(pos)\n      else graph(pos).flatMap(reachableSummits)\n    topo.positions\n    .filter(pos => topo(pos) == 0)\n    .map(pos => reachableSummits(pos).size)\n    .sum\n\n  def part1(name: String): Int =\n    solve1(getInput(name))\n")),(0,n.kt)("p",null,"As mentioned earlier, note that we don't bother memoizing. That means\nwe're doing some redundant computation (when paths branch and then\nrejoin), but the code runs plenty fast anyway on the size of input\nthat we have."),(0,n.kt)("h3",{id:"part-2"},"Part 2"),(0,n.kt)("p",null,"The code for part 2 is nearly identical. We no longer need to de-duplicate\nroutes that have the same destination, so it's now sufficient for the recursion\nto return ",(0,n.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,n.kt)("p",null,"It would certainly be possible to refactor this to share more code\nwith part 1, but I've chosen to leave it this way."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"  def solve2(topo: Topo): Int =\n    val graph = computeGraph(topo)\n    def routes(pos: Pos): Int =\n      if topo(pos) == 9\n      then 1\n      else graph(pos).toSeq.map(routes).sum\n    topo.positions\n    .filter(pos => topo(pos) == 0)\n    .map(routes)\n    .sum\n\n  def part2(name: String): Int =\n    solve2(getInput(name))\n")),(0,n.kt)("p",null,"One tricky bit here is the necessity to include ",(0,n.kt)("inlineCode",{parentName:"p"},"toSeq")," when\nrecursing. That's because we have a ",(0,n.kt)("inlineCode",{parentName:"p"},"Set[Pos]"),", but if we ",(0,n.kt)("inlineCode",{parentName:"p"},".map(...)"),"\non a ",(0,n.kt)("inlineCode",{parentName:"p"},"Set"),", the result will also be a ",(0,n.kt)("inlineCode",{parentName:"p"},"Set"),". But we don't want to\nthrow away duplicate counts."),(0,n.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D10T2.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/10/10.worksheet.sc#L166"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/samuelchassot/AdventCode_2024/blob/8cc89587c8558c7f55e2e0a3d6868290f0c5a739/10/Day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/samuelchassot"},"Samuel Chassot")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day10/src/main/scala/Solution.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/10/solution.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/main/src/aoc2024/Day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DayTen.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day10/hoof-it.sc"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer/adventofcode2024/blob/e163baeaedcd90732b5e19f578a2faadeb1ef872/src/main/scala/day10.sc"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day10.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day10"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,n.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);