"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3530],{1568:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));a(6340);const o={},r="Day 17: Chronospatial Computer",s={unversionedId:"2024/puzzles/day17",id:"2024/puzzles/day17",title:"Day 17: Chronospatial Computer",description:"by @shardulc",source:"@site/target/mdoc/2024/puzzles/day17.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day17",permalink:"/scala-advent-of-code/2024/puzzles/day17",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day17.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 16: Reindeer Maze",permalink:"/scala-advent-of-code/2024/puzzles/day16"},next:{title:"Day 18: RAM Run",permalink:"/scala-advent-of-code/2024/puzzles/day18"}},l={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Summary",id:"summary",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],h={toc:p};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-17-chronospatial-computer"},"Day 17: Chronospatial Computer"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/shardulc"},"@shardulc")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/17"},"https://adventofcode.com/2024/day/17")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("h3",{id:"summary"},"Summary"),(0,i.kt)("p",null,"The puzzle doesn\u2019t even try to disguise it\u2014we have to build a small register machine to execute bytecode! Seems fun, and suggests (to me) a design with a case class to represent the state (including the program) and a step method to compute the result of a single instruction, that we can ",(0,i.kt)("em",{parentName:"p"},"unfold")," to run the program. (More about unfolding at the end of the next section.) Part\xa02 is not an extension of Part\xa01 like usual but uses the executor to solve the inverse problem of finding an initial state that produces a certain output."),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"Let\u2019s start by defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"Machine")," class to represent the state of the register machine, with the values of the three registers, the program, and the instruction pointer as parameters. As the state is entirely determined by these parameters (there is no encapsulation, internal invariants, etc.), a ",(0,i.kt)("inlineCode",{parentName:"p"},"case class")," makes more sense than a ",(0,i.kt)("inlineCode",{parentName:"p"},"class"),". The machine can possibly take a step (or it is halted), and if it does, it can possibly produce a number as output, but always results in a next state of the machine. We will encode both these \u201cpossibly\u201ds with ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),"s."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Machine(regA: Long, regB: Long, regC: Long,\n    program: List[Int], ip: Int):\n\n  def step: Option[(Option[Int], Machine)] =\n    ???\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"NB:")," We use ",(0,i.kt)("inlineCode",{parentName:"p"},"Long"),"s for the registers for now, hoping that that is big enough for the actual input, as the puzzle description says they could be arbitrary integers. We can always switch to ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt"),"s if needed."),(0,i.kt)("p",null,"Parsing the input into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Machine")," is relatively straightforward. I adhere to my usual challenge of parsing only with the line iterator without reading the whole file contents into memory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object Day17:\n  def parse(inputFile: String): Machine =\n    val file = io.Source.fromFile(inputFile)\n    try\n      val input = file.getLines()\n      val regA = Integer.parseInt(input.next().split(": ")(1))\n      val regB = Integer.parseInt(input.next().split(": ")(1))\n      val regC = Integer.parseInt(input.next().split(": ")(1))\n      // a blank line separates the registers from the program\n      assert(input.next() == "")\n      val program = input.next().split(": ")(1).split(",").map(Integer.parseInt).toList\n      Machine(regA, regB, regC, program, 0)\n    finally\n      file.close()\n')),(0,i.kt)("p",null,"Now, let\u2019s implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"step")," method. This is also a relatively straightforward translation from the puzzle description:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The only case in which the machine halts is if the instruction pointer goes out of bounds, so we start with ",(0,i.kt)("inlineCode",{parentName:"li"},"program.lift(ip)")," (opcode) and ",(0,i.kt)("inlineCode",{parentName:"li"},"program.lift(ip + 1)")," (operand) to wrap the rest of the logic (see my ",(0,i.kt)("a",{parentName:"li",href:"day15"},"Day 15 write-up")," if you want a little explanation about ",(0,i.kt)("inlineCode",{parentName:"li"},"lift"),")."),(0,i.kt)("li",{parentName:"ul"},"We pattern match on the opcode to implement the instructions, observing that for most instructions, the program doesn\u2019t produce any output, and increments ",(0,i.kt)("inlineCode",{parentName:"li"},"ip")," by 2. Also, ",(0,i.kt)("inlineCode",{parentName:"li"},"combo")," is an obvious helper method to write."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"adv"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"bdv"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"cdv")," instructions are specified in a kind of roundabout way in the puzzle: they\u2019re just computing a right shift! It took me embarassingly long to realize this.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Machine(regA: Long, regB: Long, regC: Long,\n    program: List[Int], ip: Int):\n\n  def combo(operand: Int): Long =\n    operand match\n      case 0 | 1 | 2 | 3 => operand.toLong\n      case 4 => regA\n      case 5 => regB\n      case 6 => regC\n      case _ => throw AssertionError("should be unreachable")\n\n  def step: Option[(Option[Int], Machine)] =\n    program.lift(ip).flatMap{ opcode =>\n      program.lift(ip + 1).map{ operand =>\n        opcode match\n          case 3 if regA != 0 => (None, this.copy(ip = operand))\n          case 5 =>\n            (Some((combo(operand) % 8).toInt), this.copy(ip = ip + 2))\n          case _ =>\n            (None, (opcode match\n                case 0 => this.copy(regA = regA >> combo(operand))\n                case 1 => this.copy(regB = regB ^ operand)\n                case 2 => this.copy(regB = combo(operand) % 8)\n                case 3 => this // if regA == 0\n                case 4 => this.copy(regB = regB ^ regC)\n                case 6 => this.copy(regB = regA >> combo(operand))\n                case 7 => this.copy(regC = regA >> combo(operand)))\n              .copy(ip = ip + 2))}}\n')),(0,i.kt)("p",null,"Nifty Scala features at play:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Guards in pattern match cases let us write",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"opcode match\n  case 3 if regA != 0 => /* ... */\n  case /* ... */\n"))),(0,i.kt)("li",{parentName:"ul"},"Case classes come with an automatic ",(0,i.kt)("inlineCode",{parentName:"li"},"copy")," method that takes named arguments for just the parameters that should be different in the copy.")),(0,i.kt)("p",null,"Finally, we want to repeatedly call ",(0,i.kt)("inlineCode",{parentName:"p"},"step")," until it produces ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," (i.e., the machine halts), collecting the outputs, if any, along the way. This is an ",(0,i.kt)("em",{parentName:"p"},"unfold")," operation. Unfolding is a kind of dual of folding. If ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," is the type of the state and ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the type of inputs/outputs, then the (simplified) signatures of these operations are"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(left) fold: ",(0,i.kt)("inlineCode",{parentName:"li"},"S => ((S, T) => S) => Seq[T] => S")," ",(0,i.kt)("br",null),"\n(initial state, transition function, list of inputs, final state)"),(0,i.kt)("li",{parentName:"ul"},"unfold: ",(0,i.kt)("inlineCode",{parentName:"li"},"S => (S => Option[(T, S)]) => Seq[T]")," ",(0,i.kt)("br",null),"\n(initial state, output-producing transition function (",(0,i.kt)("inlineCode",{parentName:"li"},"None")," represents halting), list of outputs)")),(0,i.kt)("p",null,"Notice that it doesn\u2019t quite mirror folding in that it doesn\u2019t give us the final (halting) state. (We don\u2019t strictly need to know the final state to solve this puzzle, but it was essential when I was writing/debugging the program to see what was happening.) We can address this with a small extension to ",(0,i.kt)("inlineCode",{parentName:"p"},"Seq.unfold")," that produces a ",(0,i.kt)("inlineCode",{parentName:"p"},"(Seq[T], S)")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def unfoldAndLast[S, T](initial: S)(f: S => Option[(T, S)]): (Seq[T], S) =\n  val s = Seq.unfold(initial)(a => f(a).map(ta => ((ta._1, ta._2), ta._2)))\n  (s.map(_._1), s.last._2)\n")),(0,i.kt)("p",null,"We specialize ",(0,i.kt)("inlineCode",{parentName:"p"},"unfoldAndLast")," to our ",(0,i.kt)("inlineCode",{parentName:"p"},"Machine"),"s and their outputs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'object Machine:\n  def run(initial: Machine): (String, Machine) =\n    val (out, _final) = unfoldAndLast(initial)(_.step)\n    // .flatten to remove the `None` output of non\u2013output-producing instructions\n    (out.flatten.mkString(","), _final)\n\nobject Day17:\n  /* ... */\n\n  def part1(inputFile: String): String =\n    Machine.run(parse(inputFile))._1\n')),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Figuring out what initial value for a register will reproduce a given program as output seems impossibly hard. And actually, it may well be impossible, but it\u2019s not what the puzzle asks for. We just have to do it for the specific program we are given. This felt like cheating or hardcoding the answer until I looked closer at the program and realized that it was quite structured:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"2,4 bst         B := A%8\n1,7 bxl         B := B^0b111\n7,5 cdv         C := A>>B\n0,3 adv         A := A>>3\n4,0 bxc         B := B^C\n1,7 bxl         B := B^0b111\n5,5 out         out B%8\n3,0 jnz         if A!=0 then loop else halt\n")),(0,i.kt)("p",null,"The program is a single loop that runs until register\xa0A becomes zero. On every iteration, register\xa0A is right-shifted by 3\xa0bits, and 1\xa0output is produced. This means that for the machine to produce 16\xa0outputs (the program itself) and then halt, bits of register\xa0A above the 48th will have to be zero, and at least one of the 3\xa0highest bits, i.e. the 48th, 47th, and 46th, will have to be nonzero. Further, the values of registers B and C from one iteration of the loop do not affect the next, as they are overwritten (",(0,i.kt)("inlineCode",{parentName:"p"},"bst")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cdv"),") before use. This means that only the value of register\xa0A at the beginning of an iteration determines the output produced in that iteration. Together with the previous observations, this implies that"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'the 1st output, which is supposed to be "2", is determined by all bits of register\xa0A;'),(0,i.kt)("li",{parentName:"ul"},'the 2nd output, which is supposed to be "4", is determined by all but the lowest 3\xa0bits;'),(0,i.kt)("li",{parentName:"ul"},'the 3rd output, which is supposed to be "1", is determined by all but the lowest 6\xa0bits;'),(0,i.kt)("li",{parentName:"ul"},"\u2026"),(0,i.kt)("li",{parentName:"ul"},'the last output, which is supposed to be "0", is determined by the highest 3\xa0bits.')),(0,i.kt)("p",null,'In fact, we can work backwards to first figure out the highest 3\xa0bits: which of the 8\xa03-bit numbers makes the output be "0"? For each of those choices, we can work out the next 3\xa0bits (because the output depends on the previous choice), and so on. (We have to try all choices that work because a choice that works for a later output may make it impossible to get a certain earlier output. In the end, we want to get the numerically smallest choice that works for all outputs.)'),(0,i.kt)("p",null,"Once we have this algorithm figured out, writing it down as Scala is not too hard. Below, in ",(0,i.kt)("inlineCode",{parentName:"p"},"nthOutputValid"),", we \u201chand-compile\u201d a single iteration of the loop as a Scala expression to check just one output value, but we could also have run the machine for a fixed number of steps instead."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"object Machine:\n  /* ... */\n\n  val part2program = List(2,4,1,7,7,5,0,3,4,0,1,7,5,5,3,0)\n\n  def nthOutputValid(regA: Long, n: Int): Boolean =\n    ((((regA%8) ^ 7) ^ (regA >> ((regA%8) ^ 7))) ^ 7)%8 == part2program(n)\n\n  def solveForInitialA: LazyList[Long] =\n    def helper(aPrefix: Long, fromN: Int): LazyList[Long] =\n      if fromN < 0 then LazyList(aPrefix)\n      else LazyList\n        // possible choices for the current 3 bits\n        .from(0 to 7)\n        // tack them on to the end of the bits we have so far\n        .map(_ | (aPrefix << 3))\n        // keep only the ones that produce the right next output digit\n        .filter(nthOutputValid(_, fromN))\n        // extend those with choices that work for earlier outputs\n        // (if none, flatMap will just omit it)\n        .flatMap(helper(_, fromN - 1))\n    helper(0, part2program.length - 1)\n    \nobject Day17:\n  /* ... */\n  def part2: Long =\n    Machine.solveForInitialA.head\n")),(0,i.kt)("p",null,"A nice Scala standard library type we use here is ",(0,i.kt)("inlineCode",{parentName:"p"},"LazyList"),"s. If we had used a plain ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),", the method would have computed all solutions and then finished evaluation; instead, the code above does only as much computation as requested (say, by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"head"),") to produce one solution, and suspends its control flow to produce another if requested later."),(0,i.kt)("p",null,"(",(0,i.kt)("em",{parentName:"p"},"Aside:")," Technically, the specifics of this problem\u2014that we only need one solution, and that the first produced will be the smallest because each 3-bit set is checked from\xa00 to\xa07, and that there is no filtering to be done after recursing\u2014are such that we could have had ",(0,i.kt)("inlineCode",{parentName:"p"},"helper")," evaluate to ",(0,i.kt)("inlineCode",{parentName:"p"},"Option[Long]"),". But (i)\xa0convincing myself or a reader that the preceding reasoning is sound would be a lot of work for unclear benefit, and (ii)\xa0the program would be brittle to changes in the problem we\u2019re trying to solve, which is not an issue in the context of this self-contained puzzle, but is generally better to avoid.)"),(0,i.kt)("h3",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def unfoldAndLast[S, T](initial: S)(f: S => Option[(T, S)]): (Seq[T], S) =\n  val s = Seq.unfold(initial)(a => f(a).map(ta => ((ta._1, ta._2), ta._2)))\n  (s.map(_._1), s.last._2)\n\ncase class Machine(regA: Long, regB: Long, regC: Long,\n    program: List[Int], ip: Int):\n\n  def combo(operand: Int): Long =\n    operand match\n      case 0 | 1 | 2 | 3 => operand.toLong\n      case 4 => regA\n      case 5 => regB\n      case 6 => regC\n      case _ => throw AssertionError("should be unreachable")\n\n  def step: Option[(Option[Int], Machine)] =\n    program.lift(ip).flatMap{ opcode =>\n      program.lift(ip + 1).map{ operand =>\n        opcode match\n          case 3 if regA != 0 => (None, this.copy(ip = operand))\n          case 5 =>\n            (Some((combo(operand) % 8).toInt), this.copy(ip = ip + 2))\n          case _ =>\n            (None, (opcode match\n                case 0 => this.copy(regA = regA >> combo(operand))\n                case 1 => this.copy(regB = regB ^ operand)\n                case 2 => this.copy(regB = combo(operand) % 8)\n                case 3 => this // if regA == 0\n                case 4 => this.copy(regB = regB ^ regC)\n                case 6 => this.copy(regB = regA >> combo(operand))\n                case 7 => this.copy(regC = regA >> combo(operand)))\n              .copy(ip = ip + 2))}}\n\n\nobject Machine:\n\n  def run(initial: Machine): (String, Machine) =\n    val (out, _final) = unfoldAndLast(initial)(_.step)\n    // .flatten to remove the `None` output of non\u2013output-producing instructions\n    (out.flatten.mkString(","), _final)\n\n  val part2program = List(2,4,1,7,7,5,0,3,4,0,1,7,5,5,3,0)\n\n  def nthOutputValid(regA: Long, n: Int): Boolean =\n    ((((regA%8) ^ 7) ^ (regA >> ((regA%8) ^ 7))) ^ 7)%8 == part2program(n)\n\n  def solveForInitialA: LazyList[Long] =\n    def helper(aPrefix: Long, fromN: Int): LazyList[Long] =\n      if fromN < 0 then LazyList(aPrefix)\n      else LazyList\n        // possible choices for the current 3 bits\n        .from(0 to 7)\n        // tack them on to the end of the bits we have so far\n        .map(_ | (aPrefix << 3))\n        // keep only the ones that produce the right next output digit\n        .filter(nthOutputValid(_, fromN))\n        // extend those with choices that work for earlier outputs\n        // (if none, flatMap will just omit it)\n        .flatMap(helper(_, fromN - 1))\n    helper(0, part2program.length - 1)\n\n\nobject Day17:\n  def parse(inputFile: String): Machine =\n    val file = io.Source.fromFile(inputFile)\n    try\n      val input = file.getLines()\n      val regA = Integer.parseInt(input.next().split(": ")(1))\n      val regB = Integer.parseInt(input.next().split(": ")(1))\n      val regC = Integer.parseInt(input.next().split(": ")(1))\n      // a blank line separates the registers from the program\n      assert(input.next() == "")\n      val program = input.next().split(": ")(1).split(",").map(Integer.parseInt).toList\n      Machine(regA, regB, regC, program, 0)\n    finally\n      file.close()\n\n  def part1(inputFile: String): String =\n    Machine.run(parse(inputFile))._1\n\n  def part2: Long =\n    Machine.solveForInitialA.head\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day17/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day17.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D17T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2024/day17.html"},"Writeup")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day17"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);