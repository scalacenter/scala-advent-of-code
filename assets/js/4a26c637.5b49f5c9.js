"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2655],{3094:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));a(6340);const l={},o="Day 6: Trash Compactor",i={unversionedId:"2025/puzzles/day06",id:"2025/puzzles/day06",title:"Day 6: Trash Compactor",description:"by @scarf005",source:"@site/target/mdoc/2025/puzzles/day06.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day06",permalink:"/scala-advent-of-code/2025/puzzles/day06",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day06.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 5: Cafeteria",permalink:"/scala-advent-of-code/2025/puzzles/day05"},next:{title:"Day 7: Laboratories",permalink:"/scala-advent-of-code/2025/puzzles/day07"}},s={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"day-6-trash-compactor"},"Day 6: Trash Compactor"),(0,r.kt)("p",null,"by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scarf005"},"@scarf005")),(0,r.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/6"},"https://adventofcode.com/2025/day/6")),(0,r.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,r.kt)("p",null,"Processing data row-by-row is usually straightforward, but handling columns can be tricky.\nHere comes ",(0,r.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/3.7.4/scala/collection/IterableOps.html#transpose-5d3"},"transpose")," to the rescue!\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"transpose")," method switches the rows and columns of a 2D collection, which is exactly what we need for this puzzle."),(0,r.kt)("h2",{id:"part-1"},"Part 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"123 328  51 64 \n 45 64  387 23 \n  6 98  215 314\n*   +   *   +\n")),(0,r.kt)("p",null,"To make working with columns easier, we'd like the inputs to be like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"123  45   6 *\n328  64  98 +\n 51 387 215 *\n 64  23 314 +\n")),(0,r.kt)("p",null,"First, let's split the input into a 2D grid:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String) = input.linesIterator.toVector // split input into lines\n  .map(_.trim.split(raw"\\s+")) // split lines into words by whitespaces\n\n// Vector(\n//   Array(123, 328, 51, 64),\n//   Array(45, 64, 387, 23),\n//   Array(6, 98, 215, 314), \n//   Array(*, +, *, +)\n// )\n')),(0,r.kt)("p",null,"After we transpose it, we get the desired output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String) = input.linesIterator.toVector\n  .map(_.trim.split(raw"\\s+"))\n  .transpose\n\n// Vector(\n//   Vector(123, 45, 6, *),\n//   Vector(328, 64, 98, +),\n//   Vector(51, 387, 215, *),\n//   Vector(64, 23, 314, +)\n// )\n')),(0,r.kt)("p",null,"Now it's a matter of processing each column, which is fairly straightforward.\nLet's define an ",(0,r.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/reference/contextual/extension-methods.html"},"extension method")," to improve readability."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'extension (xs: Iterator[(symbol: String, nums: IterableOnce[String])])\n  def calculate: Long = xs.iterator.collect {\n    case ("*", nums) => nums.iterator.map(_.toLong).product\n    case ("+", nums) => nums.iterator.map(_.toLong).sum\n  }.sum\n')),(0,r.kt)("p",null,"Finally:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String): Long = input.linesIterator.toVector\n  .map(_.trim.split(raw"\\s+"))\n  .transpose\n  .iterator\n  .map { col => (col.last, col.init) }\n  .calculate\n')),(0,r.kt)("h2",{id:"part-2"},"Part 2"),(0,r.kt)("p",null,"This time it's tricky, but what if we transpose the entire input string?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"123 328  51 64 \n 45 64  387 23 \n  6 98  215 314\n*   +   *   +\n")),(0,r.kt)("p",null,"would become"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1  *\n24\n356\n\n369+\n248\n8\n\n 32*\n581\n175\n\n623+\n431\n  4\n")),(0,r.kt)("p",null,"Which is exactly what we need to calculate cephalopod math!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String) =\n  val lines = input.linesIterator.toVector // get list of lines\n  val ops = lines.last.split(raw"\\s+").iterator // we\'ll use them later\n  lines\n    .init // transposing requires all rows to be of equal length, so remove symbols from last line for simplicity\n    .transpose\n\n// Vector(\n//   Vector(1,  ,  ),\n//   Vector(2, 4,  ),\n//   Vector(3, 5, 6),\n//   Vector( ,  ,  ),\n//   Vector(3, 6, 9),\n//   Vector(2, 4, 8),\n//   Vector(8,  ,  ),\n//   Vector( ,  ,  ),\n//   Vector( , 3, 2),\n//   Vector(5, 8, 1),\n//   Vector(1, 7, 5),\n//   Vector( ,  ,  ),\n//   Vector(6, 2, 3),\n//   Vector(4, 3, 1),\n//   Vector( ,  , 4)\n// )\n')),(0,r.kt)("p",null,"Now we can easily convert each column into cephalopod number strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String) =\n  val lines = input.linesIterator.toVector // get list of lines\n  val ops = lines.last.split(raw"\\s+").iterator // we\'ll use them later\n  lines.init.transpose.map(_.mkString.trim)\n\n// Vector(\n//   "1",\n//   "24",\n//   "356",\n//   "",\n//   "369",\n//   "248",\n//   "8",\n//   "",\n//   "32",\n//   "581",\n//   "175",\n//   "",\n//   "623",\n//   "431",\n//   "4",\n// )\n')),(0,r.kt)("p",null,"The only thing left is to split this Vector by separator ",(0,r.kt)("inlineCode",{parentName:"p"},'""'),". Sadly, the scala\nstandard library doesn't have an ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable.splitBy")," method (yet!), so we'll define our own:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"extension [A](xs: IterableOnce[A])\n  // we're using Vector.newBuilder to build the result efficiently\n  inline def splitBy(sep: A) =\n    val (b, cur) = (Vector.newBuilder[Vector[A]], Vector.newBuilder[A]) // b stores the result, cur stores the current chunk\n    for e <- xs.iterator do\n      if e != sep then cur += e // if current element is not the separator, add it to the current chunk\n      else { b += cur.result(); cur.clear() } // else, append the current chunk to result and clear it\n    (b += cur.result()).result() // finally, append the last chunk and return the result\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String) =\n  val lines = input.linesIterator.toVector // get list of lines\n  val ops = lines.last.split(raw"\\s+").iterator // we\'ll use them later\n  lines.init.transpose.map(_.mkString.trim).splitBy("")\n\n// Vector(\n//   Vector(1, 24, 356),\n//   Vector(369, 248, 8),\n//   Vector(32, 581, 175),\n//   Vector(623, 431, 4)\n// )\n')),(0,r.kt)("p",null,"Reusing the ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate")," extension method from part 1, we can now finish part 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Long =\n  val lines = input.linesIterator.toVector\n  val ops = lines.last.split(raw"\\s+").iterator\n  val xss = lines.init.transpose.map(_.mkString.trim).splitBy("")\n\n  (ops zip xss).calculate // zip the operations with the chunks\n')),(0,r.kt)("h2",{id:"final-code"},"Final Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'extension [A](xs: IterableOnce[A])\n  inline def splitBy(sep: A) =\n    val (b, cur) = (Vector.newBuilder[Vector[A]], Vector.newBuilder[A])\n    for e <- xs.iterator do\n      if e != sep then cur += e else { b += cur.result(); cur.clear() }\n    (b += cur.result()).result()\n\nextension (xs: Iterator[(symbol: String, nums: IterableOnce[String])])\n  def calculate: Long = xs.iterator.collect {\n    case ("*", nums) => nums.iterator.map(_.toLong).product\n    case ("+", nums) => nums.iterator.map(_.toLong).sum\n  }.sum\n\ndef part1(input: String): Long = input.linesIterator.toVector\n  .map(_.trim.split(raw"\\s+"))\n  .transpose\n  .iterator\n  .map { col => (col.last, col.view.init) }\n  .calculate\n\ndef part2(input: String): Long =\n  val lines = input.linesIterator.toVector\n  val ops = lines.last.split(raw"\\s+").iterator\n  val xss = lines.init.transpose.map(_.mkString.trim).splitBy("")\n\n  (ops zip xss).calculate\n')),(0,r.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2025/blob/master/src/main/scala/day06/Day06.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day06.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/06/solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi"},"nichobi")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2025/day06/DaySix.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day06/src/main/scala/Solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic/advent-of-code-2025/blob/main/d6/solution.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic"},"Henryk \u010cesnolovi\u010d")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day06.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2025/src/main/scala/Day6.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/counter2015/aoc2025/blob/master/src/main/scala/aoc2025/Day06.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/counter2015"},"counter2015")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day6"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}u.isMDXComponent=!0}}]);