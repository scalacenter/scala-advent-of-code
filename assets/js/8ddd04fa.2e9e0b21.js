"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4377],{3655:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));a(6340);const l={},r="Day 1: Secret Entrance",s={unversionedId:"2025/puzzles/day01",id:"2025/puzzles/day01",title:"Day 1: Secret Entrance",description:"by @spamegg1",source:"@site/target/mdoc/2025/puzzles/day01.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day01",permalink:"/scala-advent-of-code/2025/puzzles/day01",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day01.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Setup",permalink:"/scala-advent-of-code/setup"},next:{title:"Day 2: Gift Shop",permalink:"/scala-advent-of-code/2025/puzzles/day02"}},o={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Rotating the dial",id:"rotating-the-dial",level:3},{value:"Following the instructions",id:"following-the-instructions",level:3},{value:"Part 2",id:"part-2",level:2},{value:"Passing through 0",id:"passing-through-0",level:3},{value:"Clicks needed to reach zero at least once",id:"clicks-needed-to-reach-zero-at-least-once",level:3},{value:"Edge cases",id:"edge-cases",level:3},{value:"Coding the logic",id:"coding-the-logic",level:3},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-1-secret-entrance"},"Day 1: Secret Entrance"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spamegg1"},"@spamegg1")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/1"},"https://adventofcode.com/2025/day/1")),(0,i.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Iterate over each line of the input to parse the rotation instructions:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For the direction of rotation, we will use -1 (left) or 1 (right)."))),(0,i.kt)("li",{parentName:"ul"},"For part 1, rotate the dial, keeping track of how many times it hits zero."),(0,i.kt)("li",{parentName:"ul"},"For part 2, rotate the dial, keeping track of how many times it passes through zero.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For both parts, we have to be careful about the modular arithmetic and edge cases!")))),(0,i.kt)("h2",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"We can parse each line into an instruction.\nEach instruction has a direction (left/right) and magnitude, or number of clicks."),(0,i.kt)("p",null,"Let's use ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/3.7.4/docs/docs/reference/other-new-features/named-tuples.html"},"named tuples")," for a quick-and-dirty type alias:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Instr = (dir: Int, clicks: Int) // dir = \xb11\n")),(0,i.kt)("p",null,"We can parse one instruction like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseLine(line: String): Instr = line match\n  case s"L$value" => (dir = -1, clicks = value.toInt)\n  case s"R$value" => (dir = 1, clicks = value.toInt)\n')),(0,i.kt)("p",null,"Then parse all of the input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def parse(input: String) = input.linesIterator.map(parseLine)\n")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"To keep track of things, let's make a case class for the dial:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dial(pointer: Int, hits: Int)\n")),(0,i.kt)("h3",{id:"rotating-the-dial"},"Rotating the dial"),(0,i.kt)("p",null,"Let's think about how to calculate the next pointer.\nIf the values stay within the range of 0-99 then we don't have a problem.\nFor example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"pointer = 32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = 1, clicks = 67)"),"\nthen we end up at ",(0,i.kt)("inlineCode",{parentName:"p"},"32 + 67 = 99"),".\nOr if ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = -1, clicks = 29)")," then we end up at ",(0,i.kt)("inlineCode",{parentName:"p"},"32 - 29 = 3"),"."),(0,i.kt)("p",null,"What happens when we go over 100, or we go into negative values?\nFor example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"pointer = 32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = 1, clicks = 70)"),"\nthen we end up at ",(0,i.kt)("inlineCode",{parentName:"p"},"32 + 70 = 102"),", but we should be at 2 instead.\nIn this case we can reduce it modulo 100:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"scala> (32 + 70) % 100\nval res0: Int = 2\n")),(0,i.kt)("p",null,"However this does not quite work for negative values.\nFor example, if ",(0,i.kt)("inlineCode",{parentName:"p"},"pointer = 32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = -1, clicks = 43)"),"\nthen we end up at ",(0,i.kt)("inlineCode",{parentName:"p"},"32 - 43 = -11"),", which should be ",(0,i.kt)("inlineCode",{parentName:"p"},"(32 - 43) % 100 = 89")," instead."),(0,i.kt)("p",null,"But:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"scala> (32 - 43) % 100\nval res1: Int = -11\n")),(0,i.kt)("p",null,"So we need to make sure to always return a nonnegative number in the 0-99 range.\nWe will have to add 100 in case the result is negative.\nLet's make our own mod function to correct this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def mod(n: Int, modulo: Int) =\n  val res = n % modulo\n  res + (if res < 0 then modulo else 0)\n")),(0,i.kt)("p",null,"If we want to be fancy about it, we can make it ",(0,i.kt)("inlineCode",{parentName:"p"},"infix")," and into an\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/reference/contextual/extension-methods.html"},"extension method")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (n: Int)\n  infix def mod(modulo: Int) =\n    val res = n % modulo\n    res + (if res < 0 then modulo else 0)\n")),(0,i.kt)("h3",{id:"following-the-instructions"},"Following the instructions"),(0,i.kt)("p",null,"Let's write the logic for processing one instruction at a time.\nIf the next pointer is at 0, we increment the hits:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dial(pointer: Int, hits: Int):\n  def rotate(instr: Instr): Dial =\n    val newPointer = (pointer + instr.dir * instr.clicks) mod 100\n    val newHits    = hits + (if newPointer == 0 then 1 else 0)\n    Dial(newPointer, newHits)\n")),(0,i.kt)("p",null,"Now process all instructions, in sequence. Initially the pointer is at 50.\nAfter, we just get the hit count of the final dial instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  val instrs = parse(input)\n  instrs\n    .foldLeft(Dial(50, 0))((dial, instr) => dial.rotate(instr))\n    .hits\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Now we need to count how many times we pass through 0 instead.\nLet's refactor our ",(0,i.kt)("inlineCode",{parentName:"p"},"Dial")," class to account for this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dial(pointer: Int, hits: Int, passes: Int)\n")),(0,i.kt)("h3",{id:"passing-through-0"},"Passing through 0"),(0,i.kt)("p",null,"Let's think about instructions with large click counts.\nSay ",(0,i.kt)("inlineCode",{parentName:"p"},"pointer = 32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = 1, clicks = 680)"),".\nThen we will end up at ",(0,i.kt)("inlineCode",{parentName:"p"},"32 + 680 = 712"),". This passes through 0 exactly 7 times:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"once at 100"),(0,i.kt)("li",{parentName:"ul"},"once at 200"),(0,i.kt)("li",{parentName:"ul"},"..."),(0,i.kt)("li",{parentName:"ul"},"once at 700"),(0,i.kt)("li",{parentName:"ul"},"finish at 712")),(0,i.kt)("p",null,"In this case the simple arithmetic ",(0,i.kt)("inlineCode",{parentName:"p"},"(32 + 680) / 100 = 7")," gives us the correct result."),(0,i.kt)("p",null,"What about negative instructions?\nSay ",(0,i.kt)("inlineCode",{parentName:"p"},"pointer = 32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"instr = (dir = -1, clicks = 680)"),".\nThis passes through 0 exactly 7 times:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"once at 0"),(0,i.kt)("li",{parentName:"ul"},"once at -100"),(0,i.kt)("li",{parentName:"ul"},"once at -200"),(0,i.kt)("li",{parentName:"ul"},"..."),(0,i.kt)("li",{parentName:"ul"},"once at -600"),(0,i.kt)("li",{parentName:"ul"},"finish at -648")),(0,i.kt)("p",null,"In this case the simple arithmetic ",(0,i.kt)("inlineCode",{parentName:"p"},"(32 - 680) / 100 = -6")," is ",(0,i.kt)("strong",{parentName:"p"},"not")," the correct result.\nNeither is its absolute value ",(0,i.kt)("inlineCode",{parentName:"p"},"-6.abs = 6"),". It seems like we are off-by-one!"),(0,i.kt)("h3",{id:"clicks-needed-to-reach-zero-at-least-once"},"Clicks needed to reach zero at least once"),(0,i.kt)("p",null,"Let's think about a correct logic for both examples.\nIt would be really awesome if we always started at 0 every time, wouldn't it?\nSo let's simplify the problem, first reach 0, then deal with the rest of it."),(0,i.kt)("p",null,"In the first example,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"starting from 32 rotating right,"),(0,i.kt)("li",{parentName:"ul"},"we first needed 68 points to reach 0 again: ",(0,i.kt)("inlineCode",{parentName:"li"},"32 + 68 = 100"),"."),(0,i.kt)("li",{parentName:"ul"},"Those 68 clicks are spent and got us to 0,"),(0,i.kt)("li",{parentName:"ul"},"now there are ",(0,i.kt)("inlineCode",{parentName:"li"},"680 - 68 = 612")," clicks to go, and we are at 0."),(0,i.kt)("li",{parentName:"ul"},"This should give us ",(0,i.kt)("inlineCode",{parentName:"li"},"612 / 100 = 6")," round trips, for a total of ",(0,i.kt)("inlineCode",{parentName:"li"},"6 + 1 = 7")," passes.")),(0,i.kt)("p",null,"In the second example,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"starting from 32 rotating left,"),(0,i.kt)("li",{parentName:"ul"},"we first needed 32 points to reach 0 again: ",(0,i.kt)("inlineCode",{parentName:"li"},"32 - 32 = 0"),"."),(0,i.kt)("li",{parentName:"ul"},"Those 32 clicks are spend and got us to 0,"),(0,i.kt)("li",{parentName:"ul"},"now there are ",(0,i.kt)("inlineCode",{parentName:"li"},"680 - 32 = 648")," clicks to go, and we are at 0."),(0,i.kt)("li",{parentName:"ul"},"This should give us ",(0,i.kt)("inlineCode",{parentName:"li"},"648 / 100 = 6")," round trips, for a total of ",(0,i.kt)("inlineCode",{parentName:"li"},"6 + 1 = 7")," passes.")),(0,i.kt)("p",null,"So the number of clicks needed to reach zero is"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"100 - pointer")," if we are rotating right (positive),"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pointer")," if we are rotating left (negative).")),(0,i.kt)("p",null,"Then we can divide the remaining clicks by 100 to count the round trips.\nSo, the number of passes will be 1 + round trips."),(0,i.kt)("h3",{id:"edge-cases"},"Edge cases"),(0,i.kt)("p",null,"What if the pointer is already at 0? Then, in either direction,\nthe number of clicks to pass through 0 again is 100, not zero!\nBecause we have to go all the way round. ",(0,i.kt)("em",{parentName:"p"},"Being")," at 0 already does not count as a pass."),(0,i.kt)("p",null,"We should also be careful with off-by-one errors.\nIf we never reach zero, round trip count will be 0, but passes ",(0,i.kt)("strong",{parentName:"p"},"won't")," be ",(0,i.kt)("inlineCode",{parentName:"p"},"1 + 0 = 1"),".\nThe passes will still be 0, because we never reached zero.\nSo we need to check if we can reach zero at least once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// val clicksToReachZero = ...\n// ...\nval passZeroAtLeastOnce = instr.clicks >= clicksToReachZero\n")),(0,i.kt)("h3",{id:"coding-the-logic"},"Coding the logic"),(0,i.kt)("p",null,"Carefully, we can put these ideas at work.\nNow our ",(0,i.kt)("inlineCode",{parentName:"p"},"rotate")," method has logic for both parts:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Dial(pointer: Int, hits: Int, passes: Int):\n  def rotate(instr: Instr): Dial =\n    // part 1\n    val newPointer = (pointer + instr.dir * instr.clicks) mod 100\n    val newHits    = hits + (if newPointer == 0 then 1 else 0)\n\n    // part 2\n    val clicksToReachZero =\n      if instr.dir == -1 then (if pointer == 0 then 100 else pointer)\n      else 100 - pointer\n    val roundTrips          = (instr.clicks - clicksToReachZero) / 100\n    val passZeroAtLeastOnce = instr.clicks >= clicksToReachZero\n    val newPasses           = passes + (if passZeroAtLeastOnce then roundTrips + 1 else 0)\n    Dial(newPointer, newHits, newPasses)\n")),(0,i.kt)("p",null,"Then we can use the same code from part 1, but get the passes at the end:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String) =\n  val instrs = parse(input)\n  instrs\n    .foldLeft(Dial(50, 0, 0))((dial, instr) => dial.rotate(instr))\n    .passes\n")),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("p",null,"I'll iterate over the instructions just once for both parts together,\nsince ",(0,i.kt)("inlineCode",{parentName:"p"},"Dial")," will contain solutions to both parts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'type Instr = (dir: Int, clicks: Int) // dir = \xb11\n\nextension (n: Int)\n  infix def mod(modulo: Int) =\n    val res = n % modulo\n    res + (if res < 0 then modulo else 0)\n\ndef parseLine(line: String): Instr = line match\n  case s"L$value" => (dir = -1, clicks = value.toInt)\n  case s"R$value" => (dir = 1, clicks = value.toInt)\n\ndef parse(input: String): Seq[Instr] = input\n  .linesIterator\n  .map(parseLine)\n  .toSeq\n\ncase class Dial(pointer: Int, hits: Int, passes: Int):\n  def rotate(instr: Instr): Dial =\n    // part 1\n    val newPointer = (pointer + instr.dir * instr.clicks) mod 100\n    val newHits    = hits + (if newPointer == 0 then 1 else 0)\n\n    // part 2\n    val clicksToReachZero =\n      if instr.dir == -1 then (if pointer == 0 then 100 else pointer)\n      else 100 - pointer\n    val roundTrips          = (instr.clicks - clicksToReachZero) / 100\n    val passZeroAtLeastOnce = instr.clicks >= clicksToReachZero\n    val newPasses           = passes + (if passZeroAtLeastOnce then roundTrips + 1 else 0)\n    Dial(newPointer, newHits, newPasses)\n\ndef part1(input: String) =\n  parse(input)\n    .foldLeft(Dial(50, 0, 0))((dial, instr) => dial.rotate(instr))\n    .hits\n\ndef part2(input: String) =\n  parse(input)\n    .foldLeft(Dial(50, 0, 0))((dial, instr) => dial.rotate(instr))\n    .passes\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day1/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha/advent-of-code-2025/blob/main/scala/2025_day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/bishabosha"},"Jamie Thompson")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2025/src/main/scala/Day1.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/johnduffell/aoc-2025/blob/main/src/main/scala/Day1.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/johnduffell"},"John Duffell")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2025/day01.html"},"Writeup")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/counter2015/aoc2025/blob/master/src/main/scala/aoc2025/Day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/counter2015"},"counter2015")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2025/blob/master/src/main/scala/day01/Day01.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/01/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2025/day01/DayOne.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}u.isMDXComponent=!0}}]);