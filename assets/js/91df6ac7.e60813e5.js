"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5934],{128:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>i});var a=t(7462),r=(t(7294),t(3905));t(6340);const l={},s="Day 19: Aplenty",o={unversionedId:"2023/puzzles/day19",id:"2023/puzzles/day19",title:"Day 19: Aplenty",description:"by @mbovel",source:"@site/target/mdoc/2023/puzzles/day19.md",sourceDirName:"2023/puzzles",slug:"/2023/puzzles/day19",permalink:"/scala-advent-of-code/2023/puzzles/day19",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2023/puzzles/day19.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 18: Lavaduct Lagoon",permalink:"/scala-advent-of-code/2023/puzzles/day18"},next:{title:"Day 20: Pulse Propagation",permalink:"/scala-advent-of-code/2023/puzzles/day20"}},c={},i=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Data structures",id:"data-structures",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Part 1 \u2013 Evaluation",id:"part-1--evaluation",level:2},{value:"Part 2 \u2013 Symbolic execution",id:"part-2--symbolic-execution",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:i};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"day-19-aplenty"},"Day 19: Aplenty"),(0,r.kt)("p",null,"by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mbovel"},"@mbovel")),(0,r.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://adventofcode.com/2023/day/19"},"https://adventofcode.com/2023/day/19")),(0,r.kt)("h2",{id:"data-structures"},"Data structures"),(0,r.kt)("p",null,"We define the following data structures for today's puzzle:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"enum Channel:\n  case X, M, A, S\n\nenum Operator:\n  case LessThan, GreaterThan\n\nenum Result:\n  case Reject, Accept\n\nenum Instruction:\n  case IfThenElse(\n      channel: Channel,\n      operator: Operator,\n      value: Int,\n      thenBranch: GoTo | Return,\n      elseBranch: Instruction\n  )\n  case Return(result: Result)\n  case GoTo(target: String)\n\nimport Instruction.*\n\ntype Workflow = Map[String, Instruction]\n\ncase class Part(x: Int, m: Int, a: Int, s: Int)\n")),(0,r.kt)("h2",{id:"parsing"},"Parsing"),(0,r.kt)("p",null,"Then, we write the associated parsing methods, using ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"split")," method and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/tour/regular-expression-patterns.html"},"regular expression patterns")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'object Channel:\n  def parse(input: String): Channel =\n    input match\n      case "x" => Channel.X\n      case "m" => Channel.M\n      case "a" => Channel.A\n      case "s" => Channel.S\n      case _   => throw Exception(s"Invalid channel: $input")\n\nobject Operator:\n  def parse(input: String): Operator =\n    input match\n      case "<" => Operator.LessThan\n      case ">" => Operator.GreaterThan\n      case _   => throw Exception(s"Invalid operator: $input")\n\nobject Result:\n  def parse(input: String): Result =\n    input match\n      case "R" => Result.Reject\n      case "A" => Result.Accept\n      case _   => throw Exception(s"Invalid result: $input")\n\nobject Instruction:\n  private val IfThenElseRegex = """([xmas])([<>])(\\d+):(\\w+),(.*)""".r\n  private val ReturnRegex = """([RA])""".r\n  private val GoToRegex = """(\\w+)""".r\n  def parse(input: String): Instruction =\n    input match\n      case IfThenElseRegex(channel, operator, value, thenBranch, elseBranch) =>\n        Instruction.parse(thenBranch) match\n          case thenBranch: (GoTo | Return) =>\n            IfThenElse(\n              Channel.parse(channel),\n              Operator.parse(operator),\n              value.toInt,\n              thenBranch,\n              Instruction.parse(elseBranch)\n            )\n          case _ => throw Exception(s"Invalid then branch: $thenBranch")\n      case ReturnRegex(result) => Return(Result.parse(result))\n      case GoToRegex(target)   => GoTo(target)\n      case _ => throw Exception(s"Invalid instruction: $input")\n\nobject Workflow:\n  def parse(input: String): Workflow =\n    input.split("\\n").map(parseBlock).toMap\n\n  private val BlockRegex = """(\\w+)\\{(.*?)\\}""".r\n  private def parseBlock(input: String): (String, Instruction) =\n    input match\n      case BlockRegex(label, body) =>\n        (label, Instruction.parse(body))\n\nobject Part:\n  val PartRegex = """\\{x=(\\d+),m=(\\d+),a=(\\d+),s=(\\d+)\\}""".r\n  def parse(input: String): Part =\n    input match\n      case PartRegex(x, m, a, s) => Part(x.toInt, m.toInt, a.toInt, s.toInt)\n      case _                     => throw Exception(s"Invalid part: $input")\n')),(0,r.kt)("h2",{id:"part-1--evaluation"},"Part 1 \u2013 Evaluation"),(0,r.kt)("p",null,"These helpers allow us to implement the core logic succinctly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String): Int =\n  val Array(workflowLines, partLines) = input.split("\\n\\n")\n  val workflow = Workflow.parse(workflowLines.trim())\n  val parts = partLines.trim().split("\\n").map(Part.parse)\n\n  def eval(part: Part, instruction: Instruction): Result =\n    instruction match\n      case IfThenElse(channel, operator, value, thenBranch, elseBranch) =>\n        val channelValue = channel match\n          case Channel.X => part.x\n          case Channel.M => part.m\n          case Channel.A => part.a\n          case Channel.S => part.s\n        val result = operator match\n          case Operator.LessThan    => channelValue < value\n          case Operator.GreaterThan => channelValue > value\n        if result then eval(part, thenBranch) else eval(part, elseBranch)\n      case Return(result) => result\n      case GoTo(target)   => eval(part, workflow(target))\n\n  parts\n    .collect: part =>\n      eval(part, workflow("in")) match\n        case Result.Reject => 0\n        case Result.Accept => part.x + part.m + part.a + part.s\n    .sum\n')),(0,r.kt)("h2",{id:"part-2--symbolic-execution"},"Part 2 \u2013 Symbolic execution"),(0,r.kt)("p",null,"To solve the second part efficiently, we use ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Symbolic_execution"},"symbolic execution")," to count the number of executions of the workflow that lead to an ",(0,r.kt)("inlineCode",{parentName:"p"},"Accept")," result."),(0,r.kt)("p",null,"We represent symbolic values with the ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractPart")," structure, where the value associated to each channel is not a number, but a range of possible values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Range(from: Long, until: Long):\n  assert(from < until)\n  def count() = until - from\n\nobject Range:\n  def safe(from: Long, until: Long): Option[Range] =\n    if from < until then Some(Range(from, until)) else None\n\ncase class AbstractPart(x: Range, m: Range, a: Range, s: Range):\n  def count() = x.count() * m.count() * a.count() * s.count()\n\n  def withChannel(channel: Channel, newRange: Range) =\n    channel match\n      case Channel.X => copy(x = newRange)\n      case Channel.M => copy(m = newRange)\n      case Channel.A => copy(a = newRange)\n      case Channel.S => copy(s = newRange)\n\n  def getChannel(channel: Channel) =\n    channel match\n      case Channel.X => x\n      case Channel.M => m\n      case Channel.A => a\n      case Channel.S => s\n")),(0,r.kt)("p",null,"We will start the evaluation with abstract parts that contain all possible values for each channel: four ranges from 1 until 4001."),(0,r.kt)("p",null,"When we evaluate an ",(0,r.kt)("inlineCode",{parentName:"p"},"IfThenElse")," instruction, we split the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractPart")," into two parts, one that contains only the values that satisfy the condition, and one that contains only the values that do not satisfy the condition."),(0,r.kt)("p",null,"This is achieved with the ",(0,r.kt)("inlineCode",{parentName:"p"},"split")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractPart"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"  def split(\n      channel: Channel,\n      value: Int\n  ): (Option[AbstractPart], Option[AbstractPart]) =\n    val currentRange = getChannel(channel)\n    (\n      Range.safe(currentRange.from, value).map(withChannel(channel, _)),\n      Range.safe(value, currentRange.until).map(withChannel(channel, _))\n    )\n")),(0,r.kt)("p",null,"Using these helpers, we can implement the abstract evaluator as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Long = combinations(input, 4001)\n\nextension [T](part: (T, T)) private inline def swap: (T, T) = (part._2, part._1)\n\ndef combinations(input: String, until: Long): Long =\n  val Array(workflowLines, _) = input.split("\\n\\n")\n  val workflow = Workflow.parse(workflowLines.trim())\n\n  def count(part: AbstractPart, instruction: Instruction): Long =\n    instruction match\n      case IfThenElse(channel, operator, value, thenBranch, elseBranch) =>\n        val (trueValues, falseValues) =\n          operator match\n            case Operator.LessThan    => part.split(channel, value)\n            case Operator.GreaterThan => part.split(channel, value + 1).swap\n        trueValues.map(count(_, thenBranch)).getOrElse(0L)\n          + falseValues.map(count(_, elseBranch)).getOrElse(0L)\n      case Return(Result.Accept) => part.count()\n      case Return(Result.Reject) => 0L\n      case GoTo(target)          => count(part, workflow(target))\n\n  count(\n    AbstractPart(\n      Range(1, until),\n      Range(1, until),\n      Range(1, until),\n      Range(1, until)\n    ),\n    workflow("in")\n  )\n')),(0,r.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2023/blob/main/src/main/scala/Day19.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2023/blob/main/day19/aplenty.sc"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/advent-of-code/blob/main/2023/19/day19.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/rayrobdod/"},"Raymond Dodge")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/advent-of-code-2023-scala/blob/solutions/19.worksheet.sc#L101"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/advent-of-code-2023/blob/main/Day19.scala"},"Solution")," by ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/xRuiAlves/"},"Rui Alves"))),(0,r.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);