"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5066],{1239:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));n(6340);const l={},o="Day 10: Factory",s={unversionedId:"2025/puzzles/day10",id:"2025/puzzles/day10",title:"Day 10: Factory",description:"Puzzle description",source:"@site/target/mdoc/2025/puzzles/day10.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day10",permalink:"/scala-advent-of-code/2025/puzzles/day10",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day10.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 9: Movie Theater",permalink:"/scala-advent-of-code/2025/puzzles/day09"},next:{title:"Day 11: Reactor",permalink:"/scala-advent-of-code/2025/puzzles/day11"}},r={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Parsing the input",id:"parsing-the-input",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-10-factory"},"Day 10: Factory"),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/10"},"https://adventofcode.com/2025/day/10")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"The input includes multiple lines, each of them can be handled independently, the result is the sum from the output of each scenario."),(0,i.kt)("p",null,"For part 1, I applied the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"Breadth-first Search")," algorithm (BFS), BFS allows finding the shortest-path from a state to another when every transition has the same cost, this was quick to implement and produced the correct output."),(0,i.kt)("p",null,"For part 2, BFS wasn't adequate due to the number of potential states, there is an alternative Reduce-and-conquer approach (a variation of ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm"},"Divide-and-conquer"),") which is fast enough."),(0,i.kt)("h2",{id:"parsing-the-input"},"Parsing the input"),(0,i.kt)("p",null,"Let's represent the input scenario as a case class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class InputCase(target: String, buttons: IndexedSeq[Set[Int]], joltage: IndexedSeq[Int])\n")),(0,i.kt)("p",null,"For parsing the input, I'll mix pattern matching to extract the input pieces combined with ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," utilities (",(0,i.kt)("inlineCode",{parentName:"p"},"replace")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"split"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseInput(input: String): IndexedSeq[InputCase] = {\n  input.split("\\n").collect { case s"[$lightDiagram]$buttonsStr{$joltageStr}" =>\n    val buttons = buttonsStr.split(" ").filter(_.nonEmpty)\n      .map(_.replace("(", "").replace(")", "").split(",").map(_.toInt).toSet)\n      .toIndexedSeq\n    val joltage = joltageStr.split(",").map(_.toInt).toIndexedSeq\n    InputCase(target = lightDiagram, buttons = buttons, joltage = joltage)\n  }\n}\n')),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"The BFS algorithm is adequate because in every step we can take a button to produce a new state, we have to avoid visiting the same state more than once."),(0,i.kt)("p",null,"For example, given this input ",(0,i.kt)("inlineCode",{parentName:"p"},"[####] (0) (3) (0,1) (1,2)"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The target state is ",(0,i.kt)("inlineCode",{parentName:"li"},"####")," (all lights turned on)."),(0,i.kt)("li",{parentName:"ul"},"The initial state is ",(0,i.kt)("inlineCode",{parentName:"li"},"....")," (all lights off)."),(0,i.kt)("li",{parentName:"ul"},"The buttons allow toggling light ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"3"),", or, lights ",(0,i.kt)("inlineCode",{parentName:"li"},"0,1")," or lights ",(0,i.kt)("inlineCode",{parentName:"li"},"1,2"),".")),(0,i.kt)("p",null,"I have created a few helper functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flip")," receives the state from a light and toggles its value,\xa0",(0,i.kt)("inlineCode",{parentName:"li"},".")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),", and, ",(0,i.kt)("inlineCode",{parentName:"li"},"#")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"."),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transform")," receives the lights state and toggles the lights covered by a button.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def flip(value: Char): Char = if (value == '#') '.' else '#'\ndef transform(source: String, button: Set[Int]): String = {\n  source.toList.zipWithIndex.map { case (value, index) =>\n    if (button.contains(index)) flip(value)\n    else value\n  }.mkString(\"\")\n}\n")),(0,i.kt)("p",null,"The way to implement a BFS requires a ",(0,i.kt)("inlineCode",{parentName:"p"},"Queue"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),", and, a way to track the visited values, for what I used a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),"."),(0,i.kt)("p",null,"The state for the BFS can de defined with the current light's state and the number of steps required to get there:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class State(value: String, steps: Int)\n")),(0,i.kt)("p",null,"Naturally, the initial state would have ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," to be only dots (",(0,i.kt)("inlineCode",{parentName:"p"},"."),") with ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," steps."),(0,i.kt)("p",null,"Given everything described until now, it is only required to define the BFS process, for this I used a tail-recursive function that does the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When the queue is empty, there is no solution."),(0,i.kt)("li",{parentName:"ul"},"When the current state has reached the goal, return the number of steps."),(0,i.kt)("li",{parentName:"ul"},"Otherwise, find the new states that can be visited, push them to the queue and repeat.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"@scala.annotation.tailrec\ndef loop(queue: Queue[State], touched: Set[String], inputCase: InputCase): Option[Int] = {\n  queue.dequeueOption match {\n    case None => None\n    case Some((current, _)) if current.value == inputCase.target => Some(current.steps)\n    case Some((current, nextQueue)) =>\n      val newValues = inputCase.buttons\n        .map(button => transform(current.value, button))\n        .filterNot(touched.contains)\n\n      val newTouched = touched ++ newValues\n      val newStates = newValues.map { newValue => State(newValue, current.steps + 1) }\n      val newQueue = nextQueue.enqueueAll(newStates)\n\n      loop(newQueue, newTouched, inputCase)\n  }\n}\n")),(0,i.kt)("p",null,"The final piece is just wiring the existing functionality to cover each scenario and sum the results:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Unit = {\n  import scala.collection.immutable.Queue\n\n  def flip(value: Char): Char = ???\n  def transform(source: String, button: Set[Int]): String = ???\n\n  case class State(value: String, steps: Int)\n\n  @scala.annotation.tailrec\n  def loop(queue: Queue[State], touched: Set[String], inputCase: InputCase): Option[Int] = ???\n\n  def resolveCase(inputCase: InputCase): Int = {\n    val initial = inputCase.target.map(_ => '.')\n    loop(Queue(State(initial, 0)), Set(initial), inputCase)\n      .getOrElse(throw new RuntimeException(\"Answer not found\"))\n  }\n\n  val total = parseInput(input).map(resolveCase).sum\n  println(total)\n}\n")),(0,i.kt)("p",null,"There are potential alternatives to deal with this but given the input size, they are not necessary, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use a ",(0,i.kt)("inlineCode",{parentName:"li"},"BitSet")," data structure instead of the ",(0,i.kt)("inlineCode",{parentName:"li"},"String"),"."),(0,i.kt)("li",{parentName:"ul"},"Applying the same button twice does not make sense because the effect gets reverted which simplifies the problem to either use a button or not.")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"My initial reaction was that resolving this might be trivial to do by reusing the BFS implementation by changing a few operations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"State is now the joltage."),(0,i.kt)("li",{parentName:"ul"},"Instead of going from the empty state to the goal, let's go from the given joltage to ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," values."),(0,i.kt)("li",{parentName:"ul"},"Filter out invalid states (",(0,i.kt)("inlineCode",{parentName:"li"},"joltage[k] < 0"),")")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"diff --git a/Main.scala b/Main.scala\nindex 21ccc48..b98c9e4 100644\n--- a/Main.scala\n+++ b/Main.scala\n@@ -19,25 +19,26 @@ object Main extends App {\n   def part1(input: String): Unit = {\n     import scala.collection.immutable.Queue\n\n-    def flip(value: Char): Char = if (value == '#') '.' else '#'\n-    def transform(source: String, button: Set[Int]): String = {\n-      source.toList.zipWithIndex.map { case (value, index) =>\n-        if (button.contains(index)) flip(value)\n+    def isValid(source: IndexedSeq[Int]): Boolean = source.forall(_ >= 0)\n+    def transform(source: IndexedSeq[Int], button: Set[Int]): IndexedSeq[Int] = {\n+      source.zipWithIndex.map { case (value, index) =>\n+        if (button.contains(index)) value - 1\n         else value\n-      }.mkString(\"\")\n+      }\n     }\n\n-    case class State(value: String, steps: Int)\n+    case class State(value: IndexedSeq[Int], steps: Int)\n\n     @scala.annotation.tailrec\n-    def loop(queue: Queue[State], touched: Set[String], inputCase: InputCase): Option[Int] = {\n+    def loop(queue: Queue[State], touched: Set[IndexedSeq[Int]], inputCase: InputCase): Option[Int] = {\n       queue.dequeueOption match {\n         case None => None\n-        case Some((current, _)) if current.value == inputCase.target => Some(current.steps)\n+        case Some((current, _)) if current.value.forall(_ == 0) => Some(current.steps)\n         case Some((current, nextQueue)) =>\n           val newValues = inputCase.buttons\n             .map(button => transform(current.value, button))\n             .filterNot(touched.contains)\n+            .filter(isValid)\n\n           val newTouched = touched ++ newValues\n           val newStates = newValues.map { newValue => State(newValue, current.steps + 1) }\n@@ -48,7 +49,7 @@ object Main extends App {\n     }\n\n     def resolveCase(inputCase: InputCase): Int = {\n-      val initial = inputCase.target.map(_ => '.')\n+      val initial = inputCase.joltage\n       loop(Queue(State(initial, 0)), Set(initial), inputCase)\n         .getOrElse(throw new RuntimeException(\"Answer not found\"))\n     }\n")),(0,i.kt)("p",null,"This resolved the example input but it was too slow with the actual test scenarios, I tried a few heuristics to trim unnecessary paths, I also tried ",(0,i.kt)("inlineCode",{parentName:"p"},"DFS")," with prunning, ",(0,i.kt)("inlineCode",{parentName:"p"},"A*"),", and, I was close to implement a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bidirectional_search"},"bidirectional BFS"),"."),(0,i.kt)("p",null,"Eventually, I got an idea from ",(0,i.kt)("a",{parentName:"p",href:"https://old.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/"},"reddit")," about using the Reduce-and-conquer approach instead, it goes like this; if the path from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," takes ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," steps, the path from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"2T")," takes ",(0,i.kt)("inlineCode",{parentName:"p"},"2N")," steps, with this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We can try to get convert the ",(0,i.kt)("inlineCode",{parentName:"li"},"joltage")," into even numbers."),(0,i.kt)("li",{parentName:"ul"},"Resolve ",(0,i.kt)("inlineCode",{parentName:"li"},"joltage / 2"),"."),(0,i.kt)("li",{parentName:"ul"},"The answer for the current step would be ",(0,i.kt)("inlineCode",{parentName:"li"},"f(joltage / 2)*2 + currentCost"),"."),(0,i.kt)("li",{parentName:"ul"},"There are many overlaping sub-problems but we can use a cache to avoid unnecessary recomputation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"DISCLAIMER")," I have no proof that this handles every possible scenario but with the test cases I prepared, the BFS result leads to the same from this, and, the result has been accepted by Advent of Code."),(0,i.kt)("p",null,"There is an important detail to resolve part 1, applying a button more than once does not make sense because it invalidates the previous action, in the case of part 2 which uses integer values, we can focus on the value parity instead, for this, the same statement holds, applying the same button twice invalidates the previous action."),(0,i.kt)("p",null,"For example, applying the button ",(0,i.kt)("inlineCode",{parentName:"p"},"0, 3")," to joltages ",(0,i.kt)("inlineCode",{parentName:"p"},"3, 4, 5, 6")," lead to ",(0,i.kt)("inlineCode",{parentName:"p"},"2, 4, 4, 6")," (all even) but applying the same button again will revert the parity back."),(0,i.kt)("p",null,"When all joltages are even (like ",(0,i.kt)("inlineCode",{parentName:"p"},"2, 4, 4, 6"),"), we can divide each value by 2, leaving us with ",(0,i.kt)("inlineCode",{parentName:"p"},"1, 2, 2, 3"),", then, we can apply the same process recursively."),(0,i.kt)("p",null,"Having said this, let's generate all possible transitions from the available buttons, this is, all ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Subset"},"subsets")," from the given buttons, leveraging the powerful Scala stdlib, we can call the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set#subsets")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"scala> List(1, 2, 3).toSet.subsets.foreach(println)\nSet()\nSet(1)\nSet(2)\nSet(3)\nSet(1, 2)\nSet(1, 3)\nSet(2, 3)\nSet(1, 2, 3)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE"),": The empty subset is important because that allow us to take the existing joltages which could be already divisible by 2."),(0,i.kt)("p",null,"The code to generate the moves generates the transformation vector for every button, for example, in the case of a button ",(0,i.kt)("inlineCode",{parentName:"p"},"0,2"),", with ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," joltages, the transformation vector becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"1,0,1,0"),", this is the delta to apply to the joltages with the cost equal to the number of buttons required to get this combination:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val allMoves = inputCase.buttons.toSet.subsets().toList.map { set =>\n  set.foldLeft(IndexedSeq.fill(inputCase.joltage.size)(0) -> 0) { case ((acc, cost), button) =>\n    val newVector = acc.zipWithIndex.map { case (x, index) =>\n      if (button.contains(index)) x + 1\n      else x\n    }\n    newVector -> (cost + 1)\n  }\n}\n")),(0,i.kt)("p",null,"Essentially, ",(0,i.kt)("inlineCode",{parentName:"p"},"allMoves")," have the transformation options associated with the cost to apply them."),(0,i.kt)("p",null,"We'll require a cache to avoid recomputing the same value twice:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// min moves to switch the given joltages to 0\nvar cache = Map.empty[IndexedSeq[Int], Option[Int]]\n")),(0,i.kt)("p",null,"At last, the actual function to compute the cost required to transform the given joltages into 0s:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When joltages is composed by only 0s, we have the answer (no cost)."),(0,i.kt)("li",{parentName:"ul"},"When the answer for the given joltages is already cached, reuse it."),(0,i.kt)("li",{parentName:"ul"},"Otherwise, apply any transformations that lead to even-joltages, resolve the smaller problem and compute the answer, out of those options, keep the minimum cost and put it into the cache.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def f(joltage: IndexedSeq[Int]): Option[Int] = {\n  if (joltage.forall(_ == 0)) Option(0)\n  else if (cache.contains(joltage)) cache(joltage)\n  else {\n    val choices = allMoves.flatMap { case (delta, cost) =>\n      val newJoltage = joltage.zip(delta).map( (goal, diff) => goal - diff)\n\n      if (newJoltage.forall(_ >= 0) && newJoltage.forall(_ % 2 == 0))\n        f(newJoltage.map(_ / 2)).map(res => cost + (res * 2))\n      else\n        None\n    }\n\n    val best = choices.minOption\n    cache = cache + (joltage -> best)\n\n    best\n  }\n}\n")),(0,i.kt)("p",null,"Now, the whole code becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Unit = {\n  def resolveCase(inputCase: InputCase): Int = {\n    val allMoves = ???\n\n    // min moves to switch the given joltages to 0\n    var cache = Map.empty[IndexedSeq[Int], Option[Int]]\n\n    def f(joltage: IndexedSeq[Int]): Option[Int] = ???\n\n    f(inputCase.joltage).getOrElse(throw new RuntimeException("Answer not found"));\n  }\n\n  val total = parseInput(input).map(resolveCase).sum\n  println(total)\n}\n')),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class InputCase(target: String, buttons: IndexedSeq[Set[Int]], joltage: IndexedSeq[Int])\n\ndef parseInput(input: String): IndexedSeq[InputCase] = {\n  input.split("\\n").collect { case s"[$lightDiagram]$buttonsStr{$joltageStr}" =>\n    val buttons = buttonsStr.split(" ").filter(_.nonEmpty)\n      .map(_.replace("(", "").replace(")", "").split(",").map(_.toInt).toSet)\n      .toIndexedSeq\n    val joltage = joltageStr.split(",").map(_.toInt).toIndexedSeq\n    InputCase(target = lightDiagram, buttons = buttons, joltage = joltage)\n  }\n}\n\ndef part1(input: String): Unit = {\n  import scala.collection.immutable.Queue\n\n  def flip(value: Char): Char = if (value == \'#\') \'.\' else \'#\'\n  def transform(source: String, button: Set[Int]): String = {\n    source.toList.zipWithIndex.map { case (value, index) =>\n      if (button.contains(index)) flip(value)\n      else value\n    }.mkString("")\n  }\n\n  case class State(value: String, steps: Int)\n\n  @scala.annotation.tailrec\n  def loop(queue: Queue[State], touched: Set[String], inputCase: InputCase): Option[Int] = {\n    queue.dequeueOption match {\n      case None => None\n      case Some((current, _)) if current.value == inputCase.target => Some(current.steps)\n      case Some((current, nextQueue)) =>\n        val newValues = inputCase.buttons\n          .map(button => transform(current.value, button))\n          .filterNot(touched.contains)\n\n        val newTouched = touched ++ newValues\n        val newStates = newValues.map { newValue => State(newValue, current.steps + 1) }\n        val newQueue = nextQueue.enqueueAll(newStates)\n\n        loop(newQueue, newTouched, inputCase)\n    }\n  }\n\n  def resolveCase(inputCase: InputCase): Int = {\n    val initial = inputCase.target.map(_ => \'.\')\n    loop(Queue(State(initial, 0)), Set(initial), inputCase)\n      .getOrElse(throw new RuntimeException("Answer not found"))\n  }\n\n  val total = parseInput(input).map(resolveCase).sum\n  println(total)\n}\n\ndef part2(input: String): Unit = {\n  def resolveCase(inputCase: InputCase): Int = {\n    val allMoves = inputCase.buttons.toSet.subsets().toList.map { set =>\n      set.foldLeft(IndexedSeq.fill(inputCase.joltage.size)(0) -> 0) { case ((acc, cost), button) =>\n        val newVector = acc.zipWithIndex.map { case (x, index) =>\n          if (button.contains(index)) x + 1\n          else x\n        }\n        newVector -> (cost + 1)\n      }\n    }\n\n    // min moves to switch the given joltages to 0\n    var cache = Map.empty[IndexedSeq[Int], Option[Int]]\n\n    def f(joltage: IndexedSeq[Int]): Option[Int] = {\n      if (joltage.forall(_ == 0)) Option(0)\n      else if (cache.contains(joltage)) cache(joltage)\n      else {\n        val choices = allMoves.flatMap { case (delta, cost) =>\n          val newJoltage = joltage.zip(delta).map( (goal, diff) => goal - diff)\n\n          if (newJoltage.forall(_ >= 0) && newJoltage.forall(_ % 2 == 0))\n            f(newJoltage.map(_ / 2)).map(res => cost + (res * 2))\n          else\n            None\n        }\n\n        val best = choices.minOption\n        cache = cache + (joltage -> best)\n\n        best\n      }\n    }\n\n    f(inputCase.joltage).getOrElse(throw new RuntimeException("Answer not found"));\n  }\n\n  val total = parseInput(input).map(resolveCase).sum\n  println(total)\n}\n\nval input = readInput()\npart1(input)\npart2(input)\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day10.scala"},"Solution")," (and\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day10alt.scala"},"ILP Alternative"),") by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/"},"merlin")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day10/puzzle1"},"Solution (part 1)")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}c.isMDXComponent=!0}}]);