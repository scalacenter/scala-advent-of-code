"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6801],{4393:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>o});var n=a(7462),i=(a(7294),a(3905));a(6340);const l={},s="Day 5: Print Queue",r={unversionedId:"2024/puzzles/day05",id:"2024/puzzles/day05",title:"Day 5: Print Queue",description:"by @KacperFKorban",source:"@site/target/mdoc/2024/puzzles/day05.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day05",permalink:"/scala-advent-of-code/2024/puzzles/day05",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day05.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 4: Ceres Search",permalink:"/scala-advent-of-code/2024/puzzles/day04"},next:{title:"Day 6: Guard Gallivant",permalink:"/scala-advent-of-code/2024/puzzles/day06"}},u={},o=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Common part",id:"common-part",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:o};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-5-print-queue"},"Day 5: Print Queue"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/KacperFKorban"},"@KacperFKorban")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/5"},"https://adventofcode.com/2024/day/5")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"We can treat the data as a graph, where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ordering rules represent directed edges in the graph"),(0,i.kt)("li",{parentName:"ul"},"each update represents a subset of the nodes")),(0,i.kt)("p",null,"As a common part of the solution, we will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"parse the input into a list of ordering rules ",(0,i.kt)("inlineCode",{parentName:"li"},"(Int, Int)")," and a list of updates ",(0,i.kt)("inlineCode",{parentName:"li"},"List[List[Int]]")),(0,i.kt)("li",{parentName:"ul"},"represent the rules as an adjacency list ",(0,i.kt)("inlineCode",{parentName:"li"},"Map[Int, List[Int]]"))),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Part 1"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For every update, we iterate over its elements (while keeping track of the visited nodes) and for each node check that ",(0,i.kt)("strong",{parentName:"li"},"none")," of its successors were visited before it."),(0,i.kt)("li",{parentName:"ul"},"We only keep the updates that don't violate the ordering rules."),(0,i.kt)("li",{parentName:"ul"},"We compute the middle number of the valid updates."),(0,i.kt)("li",{parentName:"ul"},"The solution is the sum of the middle numbers of the valid updates."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Part 2"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Similarily to part 1, we iterate over the updates and check if the ordering rules are violated, but this time we only keep the updates that ",(0,i.kt)("strong",{parentName:"li"},"do")," violate the ordering rules."),(0,i.kt)("li",{parentName:"ul"},"To fix the ordering for each update:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"We find the nodes that have no incoming edges."),(0,i.kt)("li",{parentName:"ul"},"Then, we run a BFS starting from these nodes, making sure that we only enqueue nodes when all of their incoming edges have been visited or enqueued.")))))),(0,i.kt)("h2",{id:"common-part"},"Common part"),(0,i.kt)("p",null,"For both parts of the solution, we will parse the input into an adjacency list and a list of updates."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parseRulesAndupdates(input: String): (Map[Int, List[Int]], List[List[Int]]) =\n  val ruleRegex: Regex = """(\\d+)\\|(\\d+)""".r\n  val Array(rulesStr, updatesStr) = input.split("\\n\\n")\n  val rules: Map[Int, List[Int]] =\n    ruleRegex.findAllMatchIn(rulesStr).map { m =>\n      m.group(1).toInt -> m.group(2).toInt\n    }.toList.groupMap(_._1)(_._2)\n  val updates: List[List[Int]] =\n    updatesStr.linesIterator.map(_.split(",").map(_.toInt).toList).toList\n  (rules, updates)\n')),(0,i.kt)("p",null,"We first split the input into two parts. Then, for rules we convert them into a list of pairs ",(0,i.kt)("inlineCode",{parentName:"p"},"(Int, Int)")," using a regex and group them by the first element. For updates, we simply split them by commas and convert the elements to ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"s."),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"To check if an update is valid, we iterate over the elements of the update and check if none of the neighbors of the current node were visited before it."),(0,i.kt)("p",null,"This can be done in several ways, for example by using a recursive function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isValid(rules: Map[Int, List[Int]])(update: List[Int]): Boolean =\n  def rec(update: List[Int], visited: Set[Int] = Set.empty): Boolean = update match\n    case Nil => true\n    case updateNo :: rest =>\n      !rules.getOrElse(updateNo, List.empty).exists(visited.contains)\n        && rec(rest, visited + updateNo)\n  rec(update)\n")),(0,i.kt)("p",null,"another alternative is using ",(0,i.kt)("inlineCode",{parentName:"p"},"boundary"),"-",(0,i.kt)("inlineCode",{parentName:"p"},"break")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isValid(rules: Map[Int, List[Int]])(update: List[Int]): Boolean =\n  boundary:\n    var visited = Set.empty[Int]\n    for updateNo <- update do\n      visited += updateNo\n      if rules.getOrElse(updateNo, List.empty).exists(visited.contains) then\n        break(false)\n    true\n")),(0,i.kt)("p",null,"or a ",(0,i.kt)("inlineCode",{parentName:"p"},"forall")," with a local mutable state:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isValid(rules: Map[Int, List[Int]])(update: List[Int]): Boolean =\n  var visited = Set.empty[Int]\n  update.forall { updateNo =>\n    visited += updateNo\n    !rules.getOrElse(updateNo, List.empty).exists(visited.contains)\n  }\n")),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"isValid")," function, we can filter the updates and compute the middle number of the valid updates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  val (rules, updates) = parseRulesAndupdates(input)\n  updates.filter(isValid(rules)).map(us => us(us.size / 2)).sum\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"We start Part 2 by parsing and filtering the updates that violate the ordering rules, very similarly to Part 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val (rules, updates) = parseRulesAndupdates(input)\nval invalidupdates = updates.filter(!isValid(rules)(_))\n")),(0,i.kt)("p",null,"Next, to fix a single update, we first construct local adjacency lists for the relevant nodes and an inverse adjacency list to keep track of the incoming edges:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def fixUpdate(update: List[Int]): List[Int] =\n  val relevantRules = rules\n    .filter((k, vs) => update.contains(k) && vs.exists(update.contains))\n    .mapValues(_.filter(update.contains)).toMap\n  val prevsMap = relevantRules\n    .map { case (k, vs) => vs.map(_ -> k) }\n    .flatten.groupMap(_._1)(_._2)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"relevantRules")," are only those that only use the nodes from ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),", and the ",(0,i.kt)("inlineCode",{parentName:"p"},"prevsMap")," is a map from a node to its direct predecessors."),(0,i.kt)("p",null,"Then, we start with nodes that have no incoming edges and run a BFS to fix the ordering:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val startNodes = update.filter(k => !relevantRules.values.flatten.toList.contains(k))\n")),(0,i.kt)("p",null,"The BFS function takes a set of visited nodes, a queue of nodes to visit, and a list of nodes in the correct order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  def bfs(queue: Queue[Int], visited: Set[Int] = Set.empty, res: List[Int] = List.empty): List[Int] = queue.dequeueOption match\n    case None => res\n    case Some((node, queue1)) =>\n      val newVisited = visited + node\n      val newRes = res :+ node\n      val newQueue = relevantRules.getOrElse(node, List.empty)\n        .filter { n =>\n          val notVisited = !newVisited.contains(n)\n          val notInQueue = !queue1.contains(n)\n          val allPrevVisited = prevsMap.getOrElse(n, List.empty).forall(p => newVisited.contains(p) || queue1.contains(p))\n          notVisited && notInQueue && allPrevVisited\n        }\n        .foldLeft(queue1)(_.appended(_))\n      bfs(newVisited, newQueue, newRes)\n")),(0,i.kt)("p",null,"The BFS works as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the queue is empty, we return the result")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise, we dequeue a node and add it to the visited set and the result list. We enqueue all neighbors of the node that:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"have not been visited yet"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"and")," are not in the queue"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"and")," have all of their incoming edges visited or enqueued.")),(0,i.kt)("p",{parentName:"li"},"We then call the BFS function recursively with the updated queue, visited set, and result list."))),(0,i.kt)("p",null,"The result of the ",(0,i.kt)("inlineCode",{parentName:"p"},"fixUpdate")," function is call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"bfs")," function with the ",(0,i.kt)("inlineCode",{parentName:"p"},"startNodes")," in the queue."),(0,i.kt)("p",null,"The solution for ",(0,i.kt)("inlineCode",{parentName:"p"},"part2")," is then a sum of the middle numbers of the fixed updates:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"invalidUpdates.map(fixUpdate).map(us => us(us.size / 2)).sum\n")),(0,i.kt)("p",null,"The full solution for Part 2 looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"\ndef part2(input: String) =\n  val (rules, updates) = parseRulesAndupdates(input)\n  val invalidUpdates = updates.filter(!isValid(rules)(_))\n\n  def fixUpdate(update: List[Int]): List[Int] =\n    val relevantRules = rules\n      .filter((k, vs) => update.contains(k) && vs.exists(update.contains))\n      .mapValues(_.filter(update.contains)).toMap\n    val prevsMap = relevantRules\n      .map { case (k, vs) => vs.map(_ -> k) }\n      .flatten.groupMap(_._1)(_._2)\n    val startNodes = update.filter(k => !relevantRules.values.flatten.toList.contains(k))\n    def bfs(queue: Queue[Int], visited: Set[Int] = Set.empty, res: List[Int] = List.empty): List[Int] = queue.dequeueOption match\n      case None => res\n      case Some((node, queue1)) =>\n        val newVisited = visited + node\n        val newRes = res :+ node\n        val newQueue = relevantRules.getOrElse(node, List.empty)\n          .filter { n =>\n            val notVisited = !newVisited.contains(n)\n            val notInQueue = !queue1.contains(n)\n            val allPrevVisited = prevsMap.getOrElse(n, List.empty).forall(p => newVisited.contains(p) || queue1.contains(p))\n            notVisited && notInQueue && allPrevVisited\n          }\n          .foldLeft(queue1)(_.appended(_))\n        bfs(newQueue, newVisited, newRes)\n    bfs(Queue.from(startNodes))\n\n  invalidUpdates.map(fixUpdate).map(us => us(us.size / 2)).sum\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/05/05.worksheet.sc#L133"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day5/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day05.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/05/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day05.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2024/day05/DayFive.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}d.isMDXComponent=!0}}]);