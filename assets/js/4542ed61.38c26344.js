"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8212],{2003:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));a(6340);const r={},s="Day 18: RAM Run",o={unversionedId:"2024/puzzles/day18",id:"2024/puzzles/day18",title:"Day 18: RAM Run",description:"by @TheDrawingCoder-Gamer",source:"@site/target/mdoc/2024/puzzles/day18.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day18",permalink:"/scala-advent-of-code/2024/puzzles/day18",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day18.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 17: Chronospatial Computer",permalink:"/scala-advent-of-code/2024/puzzles/day17"},next:{title:"Day 19: Linen Layout",permalink:"/scala-advent-of-code/2024/puzzles/day19"}},l={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:c};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-18-ram-run"},"Day 18: RAM Run"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/TheDrawingCoder-Gamer"},"@TheDrawingCoder-Gamer")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/18"},"https://adventofcode.com/2024/day/18")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse input into a ",(0,i.kt)("inlineCode",{parentName:"li"},"List")," of points"),(0,i.kt)("li",{parentName:"ol"},"For part 1, take the first 1024 points and path-find through them"),(0,i.kt)("li",{parentName:"ol"},"For part 2, find the tipping point where pathfinding can't be done anymore")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"First, let's make the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec2i")," class for our points:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Vec2i(x: Int, y: Int):\n  def cardinalNeighbors: List[Vec2i] =\n    List(Vec2i(x - 1, y), Vec2i(x + 1, y), Vec2i(x, y - 1), Vec2i(x, y + 1))\n\n  def isContainedIn(w: Int, h: Int): Boolean =\n    x >= 0 && x < w && y >= 0 && y < h\n")),(0,i.kt)("p",null,"Then let's parse all our points. (because the example is so different from the actual input, there is special casing for it.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(str: String): (Int, Int, List[Vec2i]) =\n  val ps = str.linesIterator.map:\n    case s"$x,$y" => Vec2i(x.toInt, y.toInt)\n  .toList\n  (if ps.length == 25 then 7 else 71, if ps.length == 25 then 12 else 1024, ps)\n')),(0,i.kt)("p",null,"For both parts, we'll need a path finding function. While I would usually use a grid, because of part 2 it's easier to pathfind using a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),".\nHere's an implementation of Dijkstra's algorithim with sets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (walls: Set[Vec2i])\n  def search(gridSize: Int): Option[List[Vec2i]] =\n    def reconstructPath(cameFrom: Map[Vec2i, Vec2i], p: Vec2i): List[Vec2i] = {\n      val totalPath = mut.ListBuffer[Vec2i](p)\n      var current = p\n      while (cameFrom.contains(current)) {\n        current = cameFrom(current)\n        totalPath.prepend(current)\n      }\n      totalPath.toList\n    }\n\n    val start = Vec2i(0, 0)\n    val goal = Vec2i(gridSize - 1, gridSize - 1)\n    val cameFrom = mut.HashMap[Vec2i, Vec2i]()\n\n    val dist = mut.HashMap(start -> 0d)\n\n    val q = mut.PriorityQueue(start -> 0d)(using Ordering.by[(Vec2i, Double), Double](_._2).reverse)\n\n    while q.nonEmpty && q.head._1 != goal do\n      val (current, score) = q.dequeue()\n\n      for neighbor <- current.cardinalNeighbors.filter(it => it.isContainedIn(gridSize, gridSize) && !walls.contains(it)) do\n        val alt = score + 1d\n        if alt < dist.getOrElse(neighbor, Double.PositiveInfinity) then\n          cameFrom(neighbor) = current\n          dist(neighbor) = alt\n          q.addOne(neighbor -> alt)\n\n    q.headOption.map(it => reconstructPath(cameFrom.toMap, it._1))\n")),(0,i.kt)("p",null,"Now part 1 is just running this with the correct inputs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(str: String): Int =\n  val (size, take, walls) = parse(str)\n  walls.take(take).toSet.search(size).get.size - 1\n")),(0,i.kt)("p",null,"(We subtract 1 here to get the number of moves made, instead of the number of tiles.)"),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Part 2 is finding the point where the path is impossible to reach. A naive approach would be a linear search, and with the input size it is perfectly acceptable\n(only taking 2 seconds), but a faster approach is a binary search."),(0,i.kt)("p",null,"Part 2 is just a short code block:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(str: String): Vec2i =\n  val (size, take, walls) = parse(str)\n  Iterator.iterate(take -> walls.size): (i0, i1) =>\n    if walls.take((i0 + i1) / 2).toSet.search(size).isEmpty \n    then i0 -> (i0 + i1) / 2 else (i0 + i1) / 2 + 1 -> i1\n  .flatMap: (i0, i1) =>\n    Option.when(i0 == i1)(walls(i0 - 1))\n  .next()\n")),(0,i.kt)("p",null,"This code will need some explaining. The iterate function is iterating through a binary search: it picks the midpoint of its two endpoints\nand searches the path with that amount of bytes fallen. If the result is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", meaning there is no valid path, then it pins its higher end point\nto that midpoint and repeats. If it's ",(0,i.kt)("inlineCode",{parentName:"p"},"Some"),", meaning there is a valid path, then it pins the lower endpoint to the midpoint + 1. Doing this means you can\ninvalidate large swathes of combinations from having to be tested. Before rewriting my code to use binary search, it took around 2 seconds. This code takes\naround 50 milliseconds, so that's a 40x speedup just from using binary search."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flatMap(...).next()")," just finds the first point where ",(0,i.kt)("inlineCode",{parentName:"p"},"i0 == i1"),", or where the binary search has completed. Because we've been taking, and not indexing, we have\nto subtract one to get the proper index."),(0,i.kt)("p",null,"Final code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'case class Vec2i(x: Int, y: Int):\n  def cardinalNeighbors: List[Vec2i] =\n    List(Vec2i(x - 1, y), Vec2i(x + 1, y), Vec2i(x, y - 1), Vec2i(x, y + 1))\n\n  def isContainedIn(w: Int, h: Int): Boolean =\n    x >= 0 && x < w && y >= 0 && y < h\n\ndef parse(str: String): (Int, Int, List[Vec2i]) =\n  val ps = str.linesIterator.map:\n    case s"$x,$y" => Vec2i(x.toInt, y.toInt)\n  .toList\n  (if ps.length == 25 then 7 else 71, if ps.length == 25 then 12 else 1024, ps)\n\nextension (walls: Set[Vec2i])\n  def search(gridSize: Int): Option[List[Vec2i]] =\n    def reconstructPath(cameFrom: Map[Vec2i, Vec2i], p: Vec2i): List[Vec2i] = {\n      val totalPath = mut.ListBuffer[Vec2i](p)\n      var current = p\n      while (cameFrom.contains(current)) {\n        current = cameFrom(current)\n        totalPath.prepend(current)\n      }\n      totalPath.toList\n    }\n\n    val start = Vec2i(0, 0)\n    val goal = Vec2i(gridSize - 1, gridSize - 1)\n    val cameFrom = mut.HashMap[Vec2i, Vec2i]()\n\n    val dist = mut.HashMap(start -> 0d)\n\n    val q = mut.PriorityQueue(start -> 0d)(using Ordering.by[(Vec2i, Double), Double](_._2).reverse)\n\n    while q.nonEmpty && q.head._1 != goal do\n      val (current, score) = q.dequeue()\n\n      for neighbor <- current.cardinalNeighbors.filter(it => it.isContainedIn(gridSize, gridSize) && !walls.contains(it)) do\n        val alt = score + 1d\n        if alt < dist.getOrElse(neighbor, Double.PositiveInfinity) then\n          cameFrom(neighbor) = current\n          dist(neighbor) = alt\n          q.addOne(neighbor -> alt)\n\n    q.headOption.map(it => reconstructPath(cameFrom.toMap, it._1))\n\ndef part1(str: String): Int =\n  val (size, take, walls) = parse(str)\n  walls.take(take).toSet.search(size).get.size - 1\n\ndef part2(str: String): Vec2i =\n  val (size, take, walls) = parse(str)\n  Iterator.iterate(take -> walls.size): (i0, i1) =>\n    if walls.take((i0 + i1) / 2).toSet.search(size).isEmpty \n    then i0 -> (i0 + i1) / 2 else (i0 + i1) / 2 + 1 -> i1\n  .flatMap: (i0, i1) =>\n    Option.when(i0 == i1)(walls(i0 - 1))\n  .next()\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D18T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/18/18.worksheet.sc#L125"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day18/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day18.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day18/ram-run.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day18.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}h.isMDXComponent=!0}}]);