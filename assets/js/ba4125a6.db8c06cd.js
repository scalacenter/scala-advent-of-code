"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9138],{9706:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>p});var i=n(7462),a=(n(7294),n(3905)),l=n(6340);const s={},o="Day 9: Disk Fragmenter",r={unversionedId:"2024/puzzles/day09",id:"2024/puzzles/day09",title:"Day 9: Disk Fragmenter",description:"by @dyvrl",source:"@site/target/mdoc/2024/puzzles/day09.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day09",permalink:"/scala-advent-of-code/2024/puzzles/day09",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day09.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 8: Resonant Collinearity",permalink:"/scala-advent-of-code/2024/puzzles/day08"},next:{title:"Day 10: Hoof It",permalink:"/scala-advent-of-code/2024/puzzles/day10"}},c={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:3},{value:"Part 1",id:"part-1-1",level:4},{value:"Part 2",id:"part-2-1",level:4},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],k={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"day-9-disk-fragmenter"},"Day 9: Disk Fragmenter"),(0,a.kt)("p",null,"by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dyvrl"},"@dyvrl")),(0,a.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/9"},"https://adventofcode.com/2024/day/9")),(0,a.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Convert the input to a disk representation:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"part1"),": A sequence of optional file indices"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"part2"),": A sequence of indivisible file/free-space blocks")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Create a compact representation of this disk: Starting from the end of the disk,")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"part1"),": Move individual file indices to the leftmost free space"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"part2"),": Move file blocks to the to the leftmost free block, if any")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Compute the checksum of the resulting disk")),(0,a.kt)("h3",{id:"part-1"},"Part 1"),(0,a.kt)("p",null,"Each part will define its own ",(0,a.kt)("inlineCode",{parentName:"p"},"Disk")," type. For ",(0,a.kt)("inlineCode",{parentName:"p"},"part1"),", this will simply be a ",(0,a.kt)("inlineCode",{parentName:"p"},"Seq[Option[Int]]"),", where each charater has an assigned value:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Some(index)")," for file blocks, with their corresponding index"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"None")," for free blocks")),(0,a.kt)("p",null,"Our main driver converts the input to a ",(0,a.kt)("inlineCode",{parentName:"p"},"Disk"),", create a new compact ",(0,a.kt)("inlineCode",{parentName:"p"},"Disk")," from it and finally computes its checksum"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n\n  type Disk = Seq[Option[Int]]\n  extension(disk: Disk)\n    def checksum: Long = ???\n\n  def createDisk(input: String): Disk = ???\n\n  def compact(disk: Disk): Disk = ???\n\n  val disk = createDisk(input)\n  compact(disk).checksum\n")),(0,a.kt)("p",null,"Let's first implement ",(0,a.kt)("inlineCode",{parentName:"p"},"checksum"),": It is the sum of each file ID times its position in the disk"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"extension(disk: Disk)\n  def checksum: Long = disk\n    .zipWithIndex\n    .map(_.getOrElse(0).toLong * _) // Free blocks are mapped to 0\n    .sum\n")),(0,a.kt)("p",null,"To create our disk from the input, we need to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Convert our input to a ",(0,a.kt)("inlineCode",{parentName:"li"},"List[Int]")," ranging from 0 to 9"),(0,a.kt)("li",{parentName:"ul"},"Group elements 2 by 2 to create pairs of (file, free) blocks count"),(0,a.kt)("li",{parentName:"ul"},"Zip these groups with their indices"),(0,a.kt)("li",{parentName:"ul"},"Unroll these pairs into an actual sequence with the correct number of elements"),(0,a.kt)("li",{parentName:"ul"},"Concatenate these newly created sequences")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def createDisk(input: String): Disk =\n    val intInput = input.toList.map(_ - '0') // Convert characters to int [0, 9]\n    val fileFreeGroups = intInput.grouped(2).toVector // Last group will contain a single element\n    val zippedGroups = fileFreeGroups.zipWithIndex\n    zippedGroups.flatMap:\n      case (List(fileN, freeN), i) => \n        // File block followed by free block\n        List.fill(fileN)(Some(i)) ::: List.fill(freeN)(None)\n      case (List(fileN), i) => \n        // Final file block\n        List.fill(fileN)(Some(i))\n      case _ => Nil\n")),(0,a.kt)("p",null,"Finally, we need to compact the disk we obtain: Iterate over the disk elements, from the beginning (left)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If we encounter a free block: replace it with the last element in the disk and repeat the recursion"),(0,a.kt)("li",{parentName:"ul"},"If we encounter a file block: Append it to the result and continue with the next element in the disk")),(0,a.kt)("p",null,"All of this can be implemented using a tail-recursive function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def compact(disk: Disk): Disk =\n  @tailrec\n  def compactRec(disk: Disk, acc: Disk): Disk =\n    if disk.isEmpty then\n      acc\n    else\n      disk.head match\n        case None => compactRec(disk.last +: disk.tail.init, acc) // Take the last element, put it first and eliminate free block\n        case file@Some(_) => compactRec(disk.tail, acc :+ file) // Append the file block\n  compactRec(disk, Vector.empty)\n")),(0,a.kt)("h3",{id:"part-2"},"Part 2"),(0,a.kt)("p",null,"The code remains very similar to ",(0,a.kt)("inlineCode",{parentName:"p"},"part1"),". However this time, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Disk")," structure can't consider characters individually anymore. Consecutive file blocks are indivisible, they form a single ",(0,a.kt)("inlineCode",{parentName:"p"},"Block"),". Thus, we define a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Block")," enumeration. All ",(0,a.kt)("inlineCode",{parentName:"p"},"Block"),"s have a size, but ",(0,a.kt)("inlineCode",{parentName:"p"},"Free")," blocks do not have any index attached whereas ",(0,a.kt)("inlineCode",{parentName:"p"},"File")," blocks do:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"enum Block(val size: Int):\n  case Free(s: Int) extends Block(s)\n  case File(s: Int, i: Int) extends Block(s)\n\n  def index = this match\n    case Free(size) => None\n    case File(size, id) => Some(id)\n")),(0,a.kt)("p",null,"The main driver for ",(0,a.kt)("inlineCode",{parentName:"p"},"part2")," has the same components as the one from ",(0,a.kt)("inlineCode",{parentName:"p"},"part1"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"checksum")," remains unchanged (except to convert our new ",(0,a.kt)("inlineCode",{parentName:"li"},"Disk")," to the previous ",(0,a.kt)("inlineCode",{parentName:"li"},"Disk"),")"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"createDisk")," produces a sequence of blocks instead of flattening every character into a single sequence")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n\n  enum Block(val size: Int):\n    case Free(s: Int) extends Block(s)\n    case File(s: Int, i: Int) extends Block(s)\n\n    def index = this match\n      case Free(size) => None\n      case File(size, id) => Some(id)\n    // [...]\n\n  type Disk = Seq[Block]\n  extension(disk: Disk)\n    def checksum: Long = disk\n      .flatMap(b => Vector.fill(b.size)(b.index.getOrElse(0))) // Convert to previous `Disk`\n      .zipWithIndex\n      .map(_.toLong * _)\n      .sum\n\n  def createDisk(input: String): Disk =\n    val intInput = input.toList.map(_ - '0') // Convert characters to int [0, 9]\n    val fileFreeGroups = intInput.grouped(2).toVector // Last group will contain a single element\n    val zippedGroups = fileFreeGroups.zipWithIndex\n    zippedGroups.flatMap:\n      case (List(fileN, freeN), id) => \n        Vector(Block.File(fileN, id), Block.Free(freeN))\n      case (List(fileN), id) => \n        Vector(Block.File(fileN, id))\n      case _ => Nil\n\n  def compact(disk: Disk): Disk = ???\n\n  val disk = createDisk(input)\n  compact(disk).checksum\n")),(0,a.kt)("p",null,"This time, the compact method needs to keep contiguous file blocks in one piece. Iterate over the blocks of the disk, starting from the right:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If we encounter a free block, we prepend it to the result"),(0,a.kt)("li",{parentName:"ul"},"If we encounter a file block, we find the leftmost free block large enough to insert file block:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If we couldn't find any such free block, prepend the file block to the result"),(0,a.kt)("li",{parentName:"ul"},"Otherwise, insert the file block inside the found free block. This creates a new view of our disk that we will use for subsequent iterations. Prepend a free block of the same size as the file block to the result.")))),(0,a.kt)("p",null,"Again, this can be implemented using a tail-recursive function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def compact(disk: Disk): Disk =\n  @tailrec\n  def compactRec(disk: Disk, acc: Disk): Disk =\n    disk.lastOption match \n      case None => \n        acc\n      case Some(last@Block.Free(_)) =>\n        // Free blocks are not moved\n        compactRec(disk.init, last +: acc)\n      case Some(last@Block.File(size, _)) =>\n        // Find first block which can fit the file block\n        val fitter = disk\n          .zipWithIndex\n          .find((block, _) => block.canInsert(last))\n        \n        fitter match\n          case None => \n            // If it doesn't fit anywhere, don't move it\n            compactRec(disk.init, last +: acc)\n          case Some(free@Block.Free(_), id) =>\n            // If it fits somewhere, insert inside this free block\n            val newDisk = disk.take(id) ++ free.insert(last) ++ disk.drop(id+1).init\n            compactRec(newDisk, Block.Free(last.size) +: acc)\n          case _ => throw new MatchError(\"Unexpected block type\")\n  compactRec(disk, Vector.empty)\n")),(0,a.kt)("p",null,"Where we defined some auxiliary methods on ",(0,a.kt)("inlineCode",{parentName:"p"},"Block"),"s to simplify the code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"enum Block(val size: Int):\n  // [...]\n  def canInsert(block: Block) = this match\n    case Free(size) => size >= block.size\n    case _ => false\n\nextension (free: Block.Free)\n  def insert(b: Block): Seq[Block] = \n    if b.size < free.size then\n      Seq(b, Block.Free(free.size-b.size)) \n    else \n      Seq(b)\n")),(0,a.kt)("h2",{id:"final-code"},"Final code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n\n  type Disk = Seq[Option[Int]]\n  extension(disk: Disk)\n    def checksum: Long = disk\n      .zipWithIndex\n      .map(_.getOrElse(0).toLong * _) // Free blocks are mapped to 0\n      .sum\n\n  def createDisk(input: String): Disk =\n    val intInput = input.toList.map(_ - '0') // Convert characters to int [0, 9]\n    val fileFreeGroups = intInput.grouped(2).toVector // Last group will contain a single element\n    val zippedGroups = fileFreeGroups.zipWithIndex\n    val disk = zippedGroups.flatMap:\n      case (List(fileN, freeN), i) => \n        // File block followed by free block\n        List.fill(fileN)(Some(i)) ::: List.fill(freeN)(None)\n      case (List(fileN), i) => \n        // Final file block\n        List.fill(fileN)(Some(i))\n      case _ => Nil\n    return disk\n\n  def compact(disk: Disk): Disk =\n    @tailrec\n    def compactRec(disk: Disk, acc: Disk): Disk =\n      if disk.isEmpty then\n        acc\n      else\n        disk.head match\n          case None => compactRec(disk.last +: disk.tail.init, acc) // Take the last element, put it first and eliminate free block\n          case file@Some(_) => compactRec(disk.tail, acc :+ file) // Append the file block\n    compactRec(disk, Vector.empty)\n\n  val disk = createDisk(input)\n  compact(disk).checksum\n\ndef part2(input: String): Long =\n\n  enum Block(val size: Int):\n    case Free(s: Int) extends Block(s)\n    case File(s: Int, i: Int) extends Block(s)\n\n    def index = this match\n      case Free(size) => None\n      case File(size, id) => Some(id)\n\n    def canInsert(block: Block) = this match\n    case Free(size) => size >= block.size\n    case _ => false\n\n  extension (free: Block.Free)\n    def insert(b: Block): Seq[Block] = \n      if b.size < free.size then\n        Seq(b, Block.Free(free.size-b.size)) \n      else \n        Seq(b)\n\n  type Disk = Seq[Block]\n  extension(disk: Disk)\n    def checksum: Long = disk\n      .flatMap(b => Vector.fill(b.size)(b.index.getOrElse(0))) // Convert to previous `Disk`\n      .zipWithIndex\n      .map(_.toLong * _)\n      .sum\n\n  def createDisk(input: String): Disk =\n    val intInput = input.toList.map(_ - '0') // Convert characters to int [0, 9]\n    val fileFreeGroups = intInput.grouped(2).toVector // Last group will contain a single element\n    val zippedGroups = fileFreeGroups.zipWithIndex\n    val disk = zippedGroups.flatMap:\n      case (List(fileN, freeN), id) => \n        Vector(Block.File(fileN, id), Block.Free(freeN))\n      case (List(fileN), id) => \n        Vector(Block.File(fileN, id))\n      case _ => Nil\n    return disk\n\n  def compact(disk: Disk): Disk =\n    @tailrec\n    def compactRec(disk: Disk, acc: Disk): Disk = disk.lastOption match \n      case None => \n        acc\n      case Some(last@Block.Free(_)) =>\n        // Free blocks are not moved\n        compactRec(disk.init, last +: acc)\n      case Some(last@Block.File(size, _)) =>\n        // Find first block in which we can insert the file block\n        val fitter = disk\n          .zipWithIndex\n          .find((block, _) => block.canInsert(last))\n        \n        fitter match\n          case None => \n            // If it doesn't fit anywhere, don't move it\n            compactRec(disk.init, last +: acc)\n          case Some(free@Block.Free(_), id) =>\n            // If it fits somewhere, insert inside this free block\n            val newDisk = disk.take(id) ++ free.insert(last) ++ disk.drop(id+1).init\n            compactRec(newDisk, Block.Free(last.size) +: acc)\n          case _ => throw new MatchError(\"Unexpected block type\")\n    compactRec(disk, Vector.empty)\n\n  val disk = createDisk(input)\n  compact(disk).checksum\n")),(0,a.kt)("h3",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,a.kt)("h4",{id:"part-1-1"},"Part 1"),(0,a.kt)(l.Z,{puzzle:"day09-part1",year:"2024",mdxType:"Solver"}),(0,a.kt)("h4",{id:"part-2-1"},"Part 2"),(0,a.kt)(l.Z,{puzzle:"day09-part2",year:"2024",mdxType:"Solver"}),(0,a.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D9T2.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day09.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/09/solution.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DayNine.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day9.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day09/disk-fragmenter.sc"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day9/src/main/scala/Solution.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day9.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/src/aoc2024/Day09.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch"))),(0,a.kt)("p",null,"Share your solution to the Scala community by editing this page."))}d.isMDXComponent=!0}}]);