"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8204],{9570:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));t(6340);const r={},l="Day 4: Printing Department",o={unversionedId:"2025/puzzles/day04",id:"2025/puzzles/day04",title:"Day 4: Printing Department",description:"by @philippus",source:"@site/target/mdoc/2025/puzzles/day04.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day04",permalink:"/scala-advent-of-code/2025/puzzles/day04",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day04.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 3: Lobby",permalink:"/scala-advent-of-code/2025/puzzles/day03"},next:{title:"Day 1: Historian Hysteria",permalink:"/scala-advent-of-code/2024/puzzles/day01"}},d={},s=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:s};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-4-printing-department"},"Day 4: Printing Department"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/philippus"},"@philippus")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/4"},"https://adventofcode.com/2025/day/4")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"parse the input into a two-dimensional array representing the grid."),(0,i.kt)("li",{parentName:"ul"},"for part 1, count the accessible rolls of paper by checking all the adjacent positions for all the rolls in the grid."),(0,i.kt)("li",{parentName:"ul"},"for part 2, use the method created in part 1 repeatedly while updating the grid and keeping count until there are no\nmore accessible rolls.")),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"First the input string needs to be parsed. A two-dimensional array of characters (",(0,i.kt)("inlineCode",{parentName:"p"},"Array[Array[Char]]"),") is used to\nrepresent the grid. This makes it easy to reason about positions in the grid. And it also helps with speed, because we\ncan update the array. Split the input by the newline character, giving the rows in the grid. Than map each row, calling\n",(0,i.kt)("inlineCode",{parentName:"p"},"toCharArray"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val grid: Array[Array[Char]] = input.split('\\n').map(_.toCharArray)\n")),(0,i.kt)("p",null,"It's nice to be able to visualize the grid, just like in the puzzle description. This can be done like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def drawGrid(grid: Array[Array[Char]]): String =\n  grid.map(_.mkString).mkString(\"\\n\") :+ '\\n'\n")),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"println(drawGrid)")," on the sample input would give the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"..@@.@@@@.\n@@@.@.@.@@\n@@@@@.@.@@\n@.@@@@..@.\n@@.@@@@.@@\n.@@@@@@@.@\n.@.@.@.@@@\n@.@@@.@@@@\n.@@@@@@@@.\n@.@.@@@.@.\n")),(0,i.kt)("p",null,"This can also be helpful to figure out subtle bugs in the solution."),(0,i.kt)("p",null,"A helper method ",(0,i.kt)("inlineCode",{parentName:"p"},"countAdjacentRolls")," is created that counts the rolls of paper (@) in the 8 (or less, because of the\nedges of the grid) adjacent positions in the grid for a given position."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def countAdjacentRolls(grid: Array[Array[Char]], pos: (x: Int, y: Int)): Int =\n  val adjacentRolls =\n    for\n      cy       <- pos.y - 1 to pos.y + 1\n      cx       <- pos.x - 1 to pos.x + 1\n      if (cx, cy) != (pos.x, pos.y) // exclude given position\n      if cy >= 0 && cy < grid.length && cx >= 0 && cx < grid(cy).length // exclude out of bounds positions\n      candidate = grid(cy)(cx)\n      if candidate == '@'\n    yield\n      candidate\n  adjacentRolls.length\n")),(0,i.kt)("p",null,"To count all the accessible rolls of paper, all the positions in the grid containing a roll (@) should be checked for\nthe amount of adjacent rolls. Using calls to the ",(0,i.kt)("inlineCode",{parentName:"p"},"indices")," method of the array the positions are generated. If a\nposition contains a roll and the amount of adjacent rolls for that position is less than 4 it gets counted towards the\ntotal sum. The ",(0,i.kt)("inlineCode",{parentName:"p"},"countAccessibleRoll")," method looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def countAccessibleRolls(grid: Array[Array[Char]]): Int =\n  (for\n     y <- grid.indices\n     x <- grid(y).indices\n   yield if grid(y)(x) == '@' && countAdjacentRolls(grid, (x, y)) < 4 then 1 else 0).sum\n")),(0,i.kt)("p",null,"This already gives the correct result, but it can be made a bit nicer by also updating the grid with ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"s and showing\nthe result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def countAccessibleRollsAndUpdateGrid(grid: Array[Array[Char]]): Int =\n  var count = 0\n  for\n    y <- grid.indices\n    x <- grid(y).indices\n    if grid(y)(x) == '@' && countAdjacentRolls(grid, (x, y)) < 4\n  do\n    count += 1\n    grid(y)(x) = 'x'\n  count\n")),(0,i.kt)("p",null,"Since the grid is now updated during the loop with ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"s, the ",(0,i.kt)("inlineCode",{parentName:"p"},"countAdjacentRolls")," needs an extra (",(0,i.kt)("inlineCode",{parentName:"p"},"|| candidate == 'x'"),") condition, the\nupdated method looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def countAdjacentRolls(grid: Array[Array[Char]], pos: (x: Int, y: Int)): Int =\n  val adjacentRolls =\n    for\n      cy       <- pos.y - 1 to pos.y + 1\n      cx       <- pos.x - 1 to pos.x + 1\n      if (cx, cy) != (pos.x, pos.y) // exclude given position\n      if cy >= 0 && cy < grid.length && cx >= 0 && cx < grid(cy).length // exclude out of bounds positions\n      candidate = grid(cy)(cx)\n      if candidate == '@' || candidate == 'x'\n    yield\n      candidate\n  adjacentRolls.length\n")),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"println(drawGrid)")," after calling ",(0,i.kt)("inlineCode",{parentName:"p"},"countAccessibleRollsAndUpdateGrid(grid)")," gives:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"..xx.xx@x.\nx@@.@.@.@@\n@@@@@.x.@@\n@.@@@@..@.\nx@.@@@@.@x\n.@@@@@@@.@\n.@.@.@.@@@\nx.@@@.@@@@\n.@@@@@@@@.\nx.x.@@@.x.\n")),(0,i.kt)("p",null,"neat!"),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"To count all the removable rolls of paper the ",(0,i.kt)("inlineCode",{parentName:"p"},"countAccessibleRollsAndUpdateGrid")," method can be used repeatedly in a\nwhile loop, making sure that after each iteration, all the ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"s in the grid are replaced with a ",(0,i.kt)("inlineCode",{parentName:"p"},"."),". The complete\n",(0,i.kt)("inlineCode",{parentName:"p"},"countRemovableRolls")," method looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def countRemovableRolls(grid: Array[Array[Char]]): Int =\n  var count = 0\n  var done  = false\n  while !done do\n    val accessible = countAccessibleRollsAndUpdateGrid(grid)\n    if accessible == 0 then\n      done = true\n    else\n      count += accessible\n      for\n        y <- grid.indices\n        x <- grid(y).indices\n        if grid(y)(x) == 'x'\n      do\n        grid(y)(x) = '.'\n  count\n")),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"println(drawGrid)")," after calling ",(0,i.kt)("inlineCode",{parentName:"p"},"countRemovableRolls(grid)")," gives:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"..........\n..........\n..........\n....@@....\n...@@@@...\n...@@@@@..\n...@.@.@@.\n...@@.@@@.\n...@@@@@..\n....@@@...\n")),(0,i.kt)("p",null,"again exactly the same as in the puzzle description!"),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n  val grid: Array[Array[Char]] = input.split('\\n').map(_.toCharArray)\n  countAccessibleRolls(grid)\n\ndef part2(input: String): Long =\n  val grid: Array[Array[Char]] = input.split('\\n').map(_.toCharArray)\n  countRemovableRolls(grid)\n\ndef countAdjacentRolls(grid: Array[Array[Char]], pos: (x: Int, y: Int)): Int =\n  val adjacentRolls =\n    for\n      cy       <- pos.y - 1 to pos.y + 1\n      cx       <- pos.x - 1 to pos.x + 1\n      if (cx, cy) != (pos.x, pos.y) // exclude given position\n      if cy >= 0 && cy < grid.length && cx >= 0 && cx < grid(cy).length // exclude out of bounds positions\n      candidate = grid(cy)(cx)\n      if candidate == '@' || candidate == 'x'\n    yield\n      candidate\n  adjacentRolls.length\n\ndef countAccessibleRolls(grid: Array[Array[Char]]): Int =\n  (for\n    y <- grid.indices\n    x <- grid(y).indices\n  yield if grid(y)(x) == '@' && countAdjacentRolls(grid, (x, y)) < 4 then 1 else 0).sum\n\ndef countAccessibleRollsAndUpdateGrid(grid: Array[Array[Char]]): Int =\n  var count = 0\n  for\n    y <- grid.indices\n    x <- grid(y).indices\n    if grid(y)(x) == '@' && countAdjacentRolls(grid, (x, y)) < 4\n  do\n    count += 1\n    grid(y)(x) = 'x'\n  count\n\ndef countRemovableRolls(grid: Array[Array[Char]]): Int =\n  var count = 0\n  var done  = false\n  while !done do\n    val accessible = countAccessibleRollsAndUpdateGrid(grid)\n    if accessible == 0 then\n      done = true\n    else\n      count += accessible\n      for\n        y <- grid.indices\n        x <- grid(y).indices\n        if grid(y)(x) == 'x'\n      do\n        grid(y)(x) = '.'\n  count\n\ndef drawGrid(grid: Array[Array[Char]]): String =\n  grid.map(_.mkString).mkString(\"\\n\") :+ '\\n'\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}p.isMDXComponent=!0}}]);