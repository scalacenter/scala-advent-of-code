"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3791],{3189:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));a(6340);const l={},o="Day 20: Race Condition",s={unversionedId:"2024/puzzles/day20",id:"2024/puzzles/day20",title:"Day 20: Race Condition",description:"by @scarf005",source:"@site/target/mdoc/2024/puzzles/day20.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day20",permalink:"/scala-advent-of-code/2024/puzzles/day20",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day20.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 19: Linen Layout",permalink:"/scala-advent-of-code/2024/puzzles/day19"},next:{title:"Day 21: Keypad Conundrum",permalink:"/scala-advent-of-code/2024/puzzles/day21"}},r={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Data Structures",id:"data-structures",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Solution",id:"solution",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-20-race-condition"},"Day 20: Race Condition"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scarf005"},"@scarf005")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/20"},"https://adventofcode.com/2024/day/20")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("p",null,"Both parts of the problem are essentially the same - they ask you to find the shortest 'cheated' path. The only difference is the duration you can cheat."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse the input into start point, end point, and path"),(0,i.kt)("li",{parentName:"ol"},"For each step, collect a list of all possible cheated positions"),(0,i.kt)("li",{parentName:"ol"},"Sum cheats that would save at least 100 picoseconds")),(0,i.kt)("h2",{id:"data-structures"},"Data Structures"),(0,i.kt)("p",null,"Let's define the core data structure first: ",(0,i.kt)("inlineCode",{parentName:"p"},"Pos"),". It represents a ",(0,i.kt)("inlineCode",{parentName:"p"},"(x,y)")," position in the grid. Since ",(0,i.kt)("inlineCode",{parentName:"p"},"Pos")," will be used ",(0,i.kt)("em",{parentName:"p"},"extensively"),", we should make it as performant as possible. It's defined as an ",(0,i.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/book/types-opaque-types.html"},"opaque type"),", giving it the performance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Int")," while maintaining the ergonomics of a regular case object ",(0,i.kt)("inlineCode",{parentName:"p"},"Pos")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"opaque type Pos = Int // 1)\n\nobject Pos:\n  val up = Pos(0, -1)\n  val down = Pos(0, 1)\n  val left = Pos(-1, 0)\n  val right = Pos(1, 0)\n  val zero = Pos(0, 0)\n  inline def apply(x: Int, y: Int): Pos = y << 16 | x // 2)\n\n  extension (p: Pos)\n    inline def x = p & 0xffff // 3)\n    inline def y = p >> 16\n    inline def neighbors: List[Pos] =\n      List(p + up, p + right, p + down, p + left)\n    inline def +(q: Pos): Pos = Pos(p.x + q.x, p.y + q.y)\n    inline infix def taxiDist(q: Pos) = (p.x - q.x).abs + (p.y - q.y).abs\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1)"),": A new type ",(0,i.kt)("inlineCode",{parentName:"li"},"Pos")," is declared that isn't interchangeable with ",(0,i.kt)("inlineCode",{parentName:"li"},"Int"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2)"),": An ",(0,i.kt)("inlineCode",{parentName:"li"},"Int")," is 32 bits. The lower 16 bits store ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," and the upper 16 bits store ",(0,i.kt)("inlineCode",{parentName:"li"},"y"),". This is safe as the width and height of the given map won't exceed 65536 tiles (2^16)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3)"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"AND"),"ing with ",(0,i.kt)("inlineCode",{parentName:"li"},"0xffff")," (=",(0,i.kt)("inlineCode",{parentName:"li"},"0x0000ffff"),") keeps only the lower 16 bits, effectively extracting ",(0,i.kt)("inlineCode",{parentName:"li"},"x"),".")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"To better illustrate how ",(0,i.kt)("inlineCode",{parentName:"p"},"Pos")," works, here's the hexadecimal layout:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},"// 0x  00ff       0001\n// hex y position x position\n\nscala> 0x00ff0001\nval res1: Int = 16711681\n\n// bit-shift to extract the y poisition 0x00ff\nscala> 0x00ff0001 >> 16\nval res2: Int = 255\n\n// AND it to extract the x position 0001\nscala> 0x00ff0001 & 0x0000ffff\nval res3: Int = 1\n"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Rect")," case class marks the boundaries of the track."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension (x: Int) inline def \xb1(y: Int) = x - y to x + y // 1)\nextension (x: Inclusive)\n  inline def &(y: Inclusive) = (x.start max y.start) to (x.end min y.end) // 2)\n\ncase class Rect(x: Inclusive, y: Inclusive):\n  inline def &(that: Rect) = Rect(x & that.x, y & that.y) // 3)\n\n  def iterator: Iterator[Pos] = for // 4)\n    y <- y.iterator\n    x <- x.iterator\n  yield Pos(x, y)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1)"),": Convenience method to create a range from ",(0,i.kt)("inlineCode",{parentName:"li"},"x-y")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"x+y"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2)"),": Convenience method to create a range from the intersection of two ranges."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3)"),": Convenience method to create a new ",(0,i.kt)("inlineCode",{parentName:"li"},"Rect")," from the intersection of two Rects."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"4)"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"O(1)")," space iterator to iterate over all positions in the ",(0,i.kt)("inlineCode",{parentName:"li"},"Rect"),".")),(0,i.kt)("h2",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"The input is a large maze with a ",(0,i.kt)("strong",{parentName:"p"},"single path")," from start to end.\nSince the solution involves moving forward in the path frequently, storing the path as a set is more efficient."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Track(start: Pos, end: Pos, walls: Set[Pos], bounds: Rect)\n\nobject Track:\n  def parse(input: String) =\n    val lines = input.trim.split('\\n')\n    val bounds = Rect(0 to lines.head.size - 1, 0 to lines.size - 1)\n    val track = Track(Pos.zero, Pos.zero, Set.empty, bounds)\n    bounds.iterator.foldLeft(track) { (track, p) =>\n      lines(p.y)(p.x) match\n        case 'S' => track.copy(start = p)\n        case 'E' => track.copy(end = p)\n        case '#' => track.copy(walls = track.walls + p)\n        case _   => track\n    }\n")),(0,i.kt)("p",null,"As there's only 1 path, this algorithm works well:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Get 4 directions from current position."),(0,i.kt)("li",{parentName:"ol"},"Filter out walls and last position."),(0,i.kt)("li",{parentName:"ol"},"Repeat until end is reached.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Track(start: Pos, end: Pos, walls: Set[Pos], bounds: Rect):\n  lazy val path: Vector[Pos] = // 1)\n    inline def canMove(prev: List[Pos])(p: Pos) =\n      !walls.contains(p) && Some(p) != prev.headOption // 2)\n\n    @tailrec def go(xs: List[Pos]): List[Pos] = xs match\n      case Nil                => Nil\n      case p :: _ if p == end => xs\n      case p :: ys            => go(p.neighbors.filter(canMove(ys)) ++ xs)\n\n    go(List(start)).reverseIterator.toVector // 3)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1)"),": It needs to be ",(0,i.kt)("inlineCode",{parentName:"li"},"lazy val"),", otherwise path will be initialized in ",(0,i.kt)("inlineCode",{parentName:"li"},"Track.parse"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2)"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"ys.headOption")," gets the last position."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3)"),": We reverse it since the constructed path is from end to start.")),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("p",null,"Now that we have the path from start to end, we can calculate how much time we can save using cheats with this algorithm:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// ...\n  lazy val zipped = path.zipWithIndex\n  lazy val pathMap = zipped.toMap\n\n  def cheatedPaths(maxDist: Int) =\n    def radius(p: Pos) =\n      (Rect(p.x \xb1 maxDist, p.y \xb1 maxDist) & bounds).iterator\n        .filter(p.taxiDist(_) <= maxDist)\n\n    zipped.map { (p, i) =>                           // 1)\n      radius(p)                                      // 2)\n        .flatMap(pathMap.get)                        // 3)\n        .map { j => (j - i) - (p taxiDist path(j)) } // 4)\n        .count(_ >= 100)                             // 5)\n    }.sum\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"For all points in the path:"),(0,i.kt)("li",{parentName:"ol"},"Get all candidate cheated destinations."),(0,i.kt)("li",{parentName:"ol"},"Filter out destinations not in the path (otherwise we'll be stuck in a wall!)."),(0,i.kt)("li",{parentName:"ol"},"Calculate time saved by cheating by subtracting cheated time (",(0,i.kt)("inlineCode",{parentName:"li"},"(p taxiDist path(j))"),") from original time (",(0,i.kt)("inlineCode",{parentName:"li"},"(j - i)"),")."),(0,i.kt)("li",{parentName:"ol"},"Filter out all cheats that save at least 100 picoseconds.")),(0,i.kt)("p",null,"Since parts 1 and 2 only differ in the number of picoseconds you can cheat, implementing them is trivial:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String) =\n  val track = Track.parse(input)\n  track.cheatedPaths(2)\n\ndef part2(input: String) =\n  val track = Track.parse(input)\n  track.cheatedPaths(20)\n")),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.annotation.tailrec\nimport scala.collection.immutable.Range.Inclusive\n\nextension (x: Int) inline def \xb1(y: Int) = x - y to x + y\nextension (x: Inclusive)\n  inline def &(y: Inclusive) = (x.start max y.start) to (x.end min y.end)\n\nopaque type Pos = Int\n\nobject Pos:\n  val up = Pos(0, -1)\n  val down = Pos(0, 1)\n  val left = Pos(-1, 0)\n  val right = Pos(1, 0)\n  val zero = Pos(0, 0)\n  inline def apply(x: Int, y: Int): Pos = y << 16 | x\n\n  extension (p: Pos)\n    inline def x = p & 0xffff\n    inline def y = p >> 16\n    inline def neighbors: List[Pos] =\n      List(p + up, p + right, p + down, p + left)\n    inline def +(q: Pos): Pos = Pos(p.x + q.x, p.y + q.y)\n    inline infix def taxiDist(q: Pos) = (p.x - q.x).abs + (p.y - q.y).abs\n\ncase class Rect(x: Inclusive, y: Inclusive):\n  inline def &(that: Rect) = Rect(x & that.x, y & that.y)\n\n  def iterator: Iterator[Pos] = for\n    y <- y.iterator\n    x <- x.iterator\n  yield Pos(x, y)\n\nobject Track:\n  def parse(input: String) =\n    val lines = input.trim.split('\\n')\n    val bounds = Rect(0 to lines.head.size - 1, 0 to lines.size - 1)\n    val track = Track(Pos.zero, Pos.zero, Set.empty, bounds)\n    bounds.iterator.foldLeft(track) { (track, p) =>\n      lines(p.y)(p.x) match\n        case 'S' => track.copy(start = p)\n        case 'E' => track.copy(end = p)\n        case '#' => track.copy(walls = track.walls + p)\n        case _   => track\n    }\n\ncase class Track(start: Pos, end: Pos, walls: Set[Pos], bounds: Rect):\n  lazy val path: Vector[Pos] =\n    inline def canMove(prev: List[Pos])(p: Pos) =\n      !walls.contains(p) && Some(p) != prev.headOption\n\n    @tailrec def go(xs: List[Pos]): List[Pos] = xs match\n      case Nil                => Nil\n      case p :: _ if p == end => xs\n      case p :: ys            => go(p.neighbors.filter(canMove(ys)) ++ xs)\n\n    go(List(start)).reverseIterator.toVector\n\n  lazy val zipped = path.zipWithIndex\n  lazy val pathMap = zipped.toMap\n\n  def cheatedPaths(maxDist: Int) =\n    def radius(p: Pos) =\n      (Rect(p.x \xb1 maxDist, p.y \xb1 maxDist) & bounds).iterator\n        .filter(p.taxiDist(_) <= maxDist)\n\n    zipped.map { (p, i) =>\n      radius(p)\n        .flatMap(pathMap.get)\n        .map { j => (j - i) - (p taxiDist path(j)) }\n        .count(_ >= 100)\n    }.sum\n\ndef part1(input: String) =\n  val track = Track.parse(input)\n  track.cheatedPaths(2)\n\ndef part2(input: String) =\n  val track = Track.parse(input)\n  track.cheatedPaths(20)\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day20/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")," "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D20T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day20.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day20.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day20.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2024/day20.html"},"Writeup")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day20"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}d.isMDXComponent=!0}}]);