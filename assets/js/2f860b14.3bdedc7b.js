"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6438],{9633:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=a(7462),s=(a(7294),a(3905));a(6340);const i={},o="Day 9: Movie Theater",l={unversionedId:"2025/puzzles/day09",id:"2025/puzzles/day09",title:"Day 9: Movie Theater",description:"by @stewSquared",source:"@site/target/mdoc/2025/puzzles/day09.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day09",permalink:"/scala-advent-of-code/2025/puzzles/day09",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day09.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 8: Playground",permalink:"/scala-advent-of-code/2025/puzzles/day08"},next:{title:"Day 10: Factory",permalink:"/scala-advent-of-code/2025/puzzles/day10"}},r={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Edge Cases that don&#39;t need to be handled",id:"edge-cases-that-dont-need-to-be-handled",level:3},{value:"Alternatives and Optimizations",id:"alternatives-and-optimizations",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:c};function p(e){let{components:t,...a}=e;return(0,s.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"day-9-movie-theater"},"Day 9: Movie Theater"),(0,s.kt)("p",null,"by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/stewSquared"},"@stewSquared")),(0,s.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/9"},"https://adventofcode.com/2025/day/9")),(0,s.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,s.kt)("p",null,"We use rectangle representations and search over all possible rectangles for the maximum, filtering for part 2 by checking intersections with boundary lines."),(0,s.kt)("h3",{id:"part-1"},"Part 1"),(0,s.kt)("p",null,"For Part 1, it suffices to calculate the area for all possible rectangles, but modelling this nicely will help with Part 2, so we'll take advantage of some of the tools Scala gives us. We'll use case classes for ",(0,s.kt)("inlineCode",{parentName:"p"},"Point")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Area"),". An Area is a set representing a rectangular grid of points -- the 2D analog of a ",(0,s.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/immutable/Range.html"},(0,s.kt)("inlineCode",{parentName:"a"},"Range")),". Like a Range, it can function as a virtual collection."),(0,s.kt)("p",null,"An Area can be determined by two bounding corner points, or by the four bounding side locations. Here, we choose to represent it as the product of two ranges:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"case class Point(x: Int, y: Int)\n\ncase class Area(xRange: Range, yRange: Range)\n\nobject Area:\n  def bounding(p: Point, q: Point): Area =\n    val dx = q.x - p.x\n    val dy = q.y - p.y\n    apply(\n      xRange = p.x to q.x by (if dx == 0 then 1 else dx.sign),\n      yRange = p.y to q.y by (if dy == 0 then 1 else dy.sign)\n    )\n")),(0,s.kt)("p",null,"Now we can parse our tiles into ",(0,s.kt)("inlineCode",{parentName:"p"},"Point"),"s and construct our rectangular ",(0,s.kt)("inlineCode",{parentName:"p"},"Area"),"s. The library method, ",(0,s.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/current/scala/collection/SeqOps.html#combinations-fffffbef"},(0,s.kt)("inlineCode",{parentName:"a"},"combinations")),", gives us all possible pairs of two tiles that can be used to determine our rectangles."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'val tiles = input.collect:\n  case s"$x,$y" => Point(x.toInt, y.toInt)\n\nval rectangles = tiles.combinations(2).collect:\n  case Seq(p, q) => Area(p, q)\n.toList\n')),(0,s.kt)("p",null,"The final missing detail is the computation of the size of a rectangle. While our input values are valid ",(0,s.kt)("inlineCode",{parentName:"p"},"Int"),"s, they are large enough that size has to be computed in terms of ",(0,s.kt)("inlineCode",{parentName:"p"},"Long"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Area...:\n  def size: Long = xRange.size.toLong * yRange.size.toLong\n")),(0,s.kt)("p",null,"From here, we can compute our answer to part 1:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"val ans1 = rectangles.map(_.size).max\n")),(0,s.kt)("h3",{id:"part-2"},"Part 2"),(0,s.kt)("p",null,"Part 2 adds a single constraint: The rectangle must be wholly contained inside the boundary of a polygon drawn by connecting all the tiles with straight lines, in which case the rectangle would only be composed of red corner tiles and green inner tiles."),(0,s.kt)("p",null,"For a rectangular area to be composed only of such tiles, it is sufficient (but not necessary: see note about edge cases) that there are no border lines crossing into its inner area. The borders themselves can intersect at the edge of our rectangle, since all border lines are colored."),(0,s.kt)("p",null,"To do this, first we can represent the borders lines of the polygon with ",(0,s.kt)("inlineCode",{parentName:"p"},"Area"),"s that have a width or height of ",(0,s.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"val lines = tiles.zip(tiles.last :: tiles).map:\n  case (p, q) => Area.bounding(p, q)\n")),(0,s.kt)("p",null,"Then if we have a function that can efficiently check for intersections between two areas, we can determine that a candidate rectangle is not crossed by any border lines. If we can efficiently determine whether two ranges intersect, we can also determine whether two areas intersect:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"extension (r: Range) def intersects(s: Range): Boolean =\n  r.nonEmpty && s.nonEmpty &&\n    (s.contains(r.min) ||  r.contains(s.min))\n")),(0,s.kt)("p",null,"Now we can use this in the definition of an ",(0,s.kt)("inlineCode",{parentName:"p"},"intersects")," method for Area:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Area...:\n  def intersects(a: Area): Boolean =\n    xRange.intersects(a.xRange) && yRange.intersects(a.yRange)\n")),(0,s.kt)("p",null,"Again, since a border line can be on the edge of candidate rectangle, we actually have to compute the inner area of a rectangle, and check ",(0,s.kt)("em",{parentName:"p"},"it")," for intersections with border lines:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"// case class Area...:\n  def inner: Area =\n    Area(\n      xRange = xRange.drop(1).dropRight(1),\n      yRange = yRange.drop(1).dropRight(1)\n    )\n")),(0,s.kt)("p",null,"Now we can write a funtion that tells us an area only contains green tiles:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"def allGreen(a: Area): Boolean =\n  !lines.exists(_.intersects(a.inner))\n")),(0,s.kt)("p",null,"And our part 2 solution only needs to add this as a filter:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},"val ans2 = rectangles.filter(allGreen).map(_.size).max\n")),(0,s.kt)("h3",{id:"edge-cases-that-dont-need-to-be-handled"},"Edge Cases that don't need to be handled"),(0,s.kt)("p",null,"The shape of the input data is largely a circle, with a single rectangular incurion through its center. Because of this, there are two classes of edge cases that don't need to be handled."),(0,s.kt)("p",null,"First, when we check that a rectangle doesn't intersect any boundaries, that does not actually tell us the rectangle is fully green. It tells us that the rectangle is either fully inside or outside of the circle. Because of the shape of the input, the largest non-intersected rectangle will always be fully contained."),(0,s.kt)("p",null,"Second, boundaries can intersect our rectangle without diminishing the number of green tiles, as long as it's directly adjacent to another boundary."),(0,s.kt)("h2",{id:"alternatives-and-optimizations"},"Alternatives and Optimizations"),(0,s.kt)("p",null,"A point can be determined to be inside or outside the boundary in linear time by counting the number of lines between the edge of the grid and the point. An odd number of boundary crossings means the tile is green. This can then be used to test every point inside a candidate rectangle and would detect the edge cases missed above."),(0,s.kt)("p",null,"The number of checks can be reduced by using edge compression on the coordinates, so that entire rectangles of tiles that have no overlaps with any red tile coordinate can have their color determined at the same time. This can be used enable a fast flood fill approach which would avoid the edge cases above. Similarly, one could optimize by using a disjoint set data structure. The ",(0,s.kt)("inlineCode",{parentName:"p"},"Area")," type above can be used like a set with O(1) set membership, and the full set of green tiles could be represented by a collection of these."),(0,s.kt)("p",null,"Any alternative approaches take significantly more work, however. ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/merlinorg/"},"@merlinorg")," has provided ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/merlinorg/advent-of-code/blob/44a80dd81d54cea13255e4013ad28cf18fbfbb8e/src/main/scala/year2025/day09alt.scala"},"an example")," that handles more, but still not all, edge cases."),(0,s.kt)("h2",{id:"final-code"},"Final Code"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-scala"},'case class Point(x: Int, y: Int)\n\ncase class Area(xRange: Range, yRange: Range):\n  def size: Long = xRange.size.toLong * yRange.size.toLong\n  def inner: Area =\n    Area(\n      xRange = xRange.drop(1).dropRight(1),\n      yRange = yRange.drop(1).dropRight(1)\n    )\n\n  def intersects(a: Area): Boolean =\n    xRange.intersects(a.xRange) && yRange.intersects(a.yRange)\n\nextension (r: Range) def intersects(s: Range): Boolean =\n  r.nonEmpty && s.nonEmpty &&\n    (s.contains(r.min) ||  r.contains(s.min))\n\nobject Area:\n  def bounding(p: Point, q: Point): Area =\n    val dx = q.x - p.x\n    val dy = q.y - p.y\n    apply(\n      xRange = p.x to q.x by (if dx == 0 then 1 else dx.sign),\n      yRange = p.y to q.y by (if dy == 0 then 1 else dy.sign)\n    )\n\n\ndef part1(input: String): Long =\n  val tiles = input.collect:\n    case s"$x,$y" => Point(x.toInt, y.toInt)\n\n  val rectangles = tiles.combinations(2).collect:\n    case Seq(p, q) => Area(p, q)\n  .toList\n\n  rectangles.map(_.size).max\n\n\nval part2(input: String): Long =\n  val tiles = input.collect:\n    case s"$x,$y" => Point(x.toInt, y.toInt)\n\n  val rectangles = tiles.combinations(2).collect:\n    case Seq(p, q) => Area(p, q)\n  .toList\n\n  val lines = tiles.zip(tiles.last :: tiles).map:\n    case (p, q) => Area.bounding(p, q)\n\n  def allGreen(a: Area): Boolean =\n    !lines.exists(_.intersects(a.inner))\n\n  rectangles.filter(allGreen).map(_.size).max\n')),(0,s.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/09/solution.scala"},"Solution")," by ",(0,s.kt)("a",{parentName:"p",href:"https://nichobi.com"},"nichobi"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day09.scala"},"Solution")," by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/philippus"},"Philippus Baalman"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/stewSquared/advent-of-code/blob/master/src/main/scala/2025/Day09.worksheet.sc"},"Solution")," by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/stewSquared"},"Stewart Stewart"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://www.youtube.com/live/59KJcRlxvEE?t=2645s"},"Live solve recording")," by ",(0,s.kt)("a",{parentName:"p",href:"https://youtube.com/@stewSquared"},"Stewart Stewart"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day9"},"Solution (part 1)")," by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")))),(0,s.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}p.isMDXComponent=!0}}]);