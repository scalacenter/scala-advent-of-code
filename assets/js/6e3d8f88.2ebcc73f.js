"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5559],{554:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>m});var n=t(7462),i=(t(7294),t(3905)),s=t(6340);const r={},o="Day 8: Playground",l={unversionedId:"2025/puzzles/day08",id:"2025/puzzles/day08",title:"Day 8: Playground",description:"by @mbovel",source:"@site/target/mdoc/2025/puzzles/day08.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day08",permalink:"/scala-advent-of-code/2025/puzzles/day08",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day08.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 7: Laboratories",permalink:"/scala-advent-of-code/2025/puzzles/day07"},next:{title:"Day 9: Movie Theater",permalink:"/scala-advent-of-code/2025/puzzles/day09"}},p={},m=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Data Model",id:"data-model",level:2},{value:"Data Loading",id:"data-loading",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Potential Optimizations",id:"potential-optimizations",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1-1",level:3},{value:"Part 2",id:"part-2-1",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:m};function h(e){let{components:a,...t}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-8-playground"},"Day 8: Playground"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mbovel"},"@mbovel")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/8"},"https://adventofcode.com/2025/day/8")),(0,i.kt)("h2",{id:"data-model"},"Data Model"),(0,i.kt)("p",null,"To solve this puzzle, we use a class to represent junction boxes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"/** A junction box in 3D space with an associated circuit ID. */\ncase class Box(val x: Long, val y: Long, val z: Long, var circuit: Int):\n  def distanceSquare(other: Box): Long =\n    (x - other.x) * (x - other.x) + (y - other.y) * (y - other.y) + (z - other.z) * (z - other.z)\n")),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"Box")," has:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Three coordinates (",(0,i.kt)("inlineCode",{parentName:"li"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"z"),") representing its position in 3D space"),(0,i.kt)("li",{parentName:"ul"},"A mutable ",(0,i.kt)("inlineCode",{parentName:"li"},"circuit")," field to track which circuit the box belongs to (each circuit is identified by a distinct integer)"),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"distanceSquare")," method that computes the squared Euclidean distance to another box (we use squared distance to avoid computing square roots, since we only need to compare distances)")),(0,i.kt)("h2",{id:"data-loading"},"Data Loading"),(0,i.kt)("p",null,"The following functions parse the input into a sequence of boxes and compute all unique pairs sorted by distance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'/** Parses comma-separated coordinates from the given `line` into a `Box`\n  * with the given `circuit` ID.\n  */\ndef parseBox(line: String, circuit: Int): Box =\n  val parts = line.split(",")\n  Box(parts(0).toLong, parts(1).toLong, parts(2).toLong, circuit)\n\n/** Parses the input, returning a sequence of `Box`es and all unique pairs\n  * of boxes sorted by distance.\n  */\ndef load(input: String): (Seq[Box], Seq[(Box, Box)]) =\n  val lines = input.linesIterator.filter(_.nonEmpty)\n  val boxes = lines.zipWithIndex.map(parseBox).toSeq\n  val pairsByDistance = boxes.pairs.toSeq.sortBy((b1, b2) => b1.distanceSquare(b2))\n  (boxes, pairsByDistance)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"pairs")," extension method generates all unique pairs from a sequence:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension [T](self: Seq[T])\n  /** Generates all unique pairs (combinations of 2) from the sequence. */\n  def pairs: Iterator[(T, T)] =\n    self.combinations(2).map(pair => (pair(0), pair(1)))\n")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"For Part 1, we process the 1000 closest pairs of boxes and merge their circuits. The algorithm iterates through pairs in order of increasing distance; when two boxes belong to different circuits, we merge them into one. Finally, we find the three largest circuits and return the product of their sizes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Int =\n  val (boxes, pairsByDistance) = load(input)\n  for (b1, b2) <- pairsByDistance.take(1000) if b1.circuit != b2.circuit do\n    merge(b1.circuit, b2.circuit, boxes)\n  val sizes = boxes.groupBy(_.circuit).values.map(_.size).toSeq.sortBy(-_)\n  sizes.take(3).product\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," function updates all boxes in one circuit to belong to another:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"/** Sets all boxes with circuit `c2` to circuit `c1`. */\ndef merge(c1: Int, c2: Int, boxes: Seq[Box]): Unit =\n  for b <- boxes if b.circuit == c2 do b.circuit = c1\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"For Part 2, we continue merging circuits until only one remains. We track the number of distinct circuits and return the product of the x-coordinates of the two boxes in the final merge."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String): Long =\n  val (boxes, pairsByDistance) = load(input)\n  var n = boxes.length\n  boundary:\n    for (b1, b2) <- pairsByDistance if b1.circuit != b2.circuit do\n      merge(b1.circuit, b2.circuit, boxes)\n      n -= 1\n      if n <= 1 then\n        break(b1.x * b2.x)\n    throw Exception("Should not reach here")\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/api/3.x/scala/util/boundary$.html"},(0,i.kt)("inlineCode",{parentName:"a"},"boundary")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"break"))," provide a way to exit the loop early and return a value when only one circuit remains."),(0,i.kt)("h2",{id:"potential-optimizations"},"Potential Optimizations"),(0,i.kt)("p",null,"On my machine, both parts run in under two seconds, which is acceptable for this puzzle. Still, several optimizations are possible."),(0,i.kt)("p",null,"What we implemented is essentially the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree"},"Euclidean minimum spanning tree (EMST)")," computed via ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm"},"Kruskal\u2019s algorithm"),", after generating all pairwise distances."),(0,i.kt)("p",null,"This algorithm is normally paired with a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure"},"union\u2013find")," structure to maintain connected components efficiently. Using it would speed up our current ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," step, which is ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," per merge, and reduce it to near-constant time."),(0,i.kt)("p",null,"We could also improve how we find the ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"k")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.69444em",verticalAlign:"0em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k")))))," closest pairs. Computing all pairs and sorting them has ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,i.kt)("msup",{parentName:"mrow"},(0,i.kt)("mi",{parentName:"msup"},"n"),(0,i.kt)("mn",{parentName:"msup"},"2")),(0,i.kt)("mi",{parentName:"mrow"},"log"),(0,i.kt)("mo",{parentName:"mrow"},"\u2061"),(0,i.kt)("mi",{parentName:"mrow"},"n"),(0,i.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathcal{O}(n^2 \\log n)")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,i.kt)("span",{parentName:"span",className:"mopen"},"("),(0,i.kt)("span",{parentName:"span",className:"mord"},(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"msupsub"},(0,i.kt)("span",{parentName:"span",className:"vlist-t"},(0,i.kt)("span",{parentName:"span",className:"vlist-r"},(0,i.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,i.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,i.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,i.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,i.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mop"},"lo",(0,i.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,i.kt)("span",{parentName:"span",className:"mclose"},")")))))," complexity. A spatial index such as a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/K-d_tree"},"k-d tree")," would avoid generating all pairs and, in the average case, remove the quadratic blow-up. Another option is to restrict candidates to a geometric graph such as the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Relative_neighborhood_graph"},"relative neighborhood graph")," or the 3D ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Delaunay_triangulation"},"Delaunay triangulation"),", both of which contain the EMST and are much sparser than the complete graph."),(0,i.kt)("h2",{id:"final-code"},"Final Code"),(0,i.kt)("p",null,"See the complete code on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/blob/main/2025/src/day08.scala"},"GitHub"),"."),(0,i.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("p",null,"Thanks to the ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-js.org/"},"Scala.js")," build, you can also experiment with this code directly in the browser."),(0,i.kt)("h3",{id:"part-1-1"},"Part 1"),(0,i.kt)(s.Z,{puzzle:"day08-part1",year:"2025",mdxType:"Solver"}),(0,i.kt)("h3",{id:"part-2-1"},"Part 2"),(0,i.kt)(s.Z,{puzzle:"day08-part2",year:"2025",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day08/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic/advent-of-code-2025/blob/main/d8/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic"},"Henryk \u010cesnolovi\u010d")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day08.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/08/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://nichobi.com"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day8"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}h.isMDXComponent=!0}}]);