"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9446],{8235:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));n(6340);const i={},l="Day 11: Reactor",r={unversionedId:"2025/puzzles/day11",id:"2025/puzzles/day11",title:"Day 11: Reactor",description:"by @merlinorg",source:"@site/target/mdoc/2025/puzzles/day11.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day11",permalink:"/scala-advent-of-code/2025/puzzles/day11",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day11.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 10: Factory",permalink:"/scala-advent-of-code/2025/puzzles/day10"},next:{title:"Day 12: Christmas Tree Farm",permalink:"/scala-advent-of-code/2025/puzzles/day12"}},s={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Input Modeling",id:"input-modeling",level:4},{value:"Counting Paths",id:"counting-paths",level:4},{value:"Solution",id:"solution",level:4},{value:"Part 2",id:"part-2",level:3},{value:"Initial Solution",id:"initial-solution",level:4},{value:"The Problem",id:"the-problem",level:5},{value:"Memoization",id:"memoization",level:4},{value:"On Mutability",id:"on-mutability",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-11-reactor"},"Day 11: Reactor"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/11"},"https://adventofcode.com/2025/day/11")),(0,o.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,o.kt)("p",null,"We use a simple recursive algorithm to count the number of paths in\npart 1. We add memoization to make part 2 tractable."),(0,o.kt)("h3",{id:"part-1"},"Part 1"),(0,o.kt)("p",null,"Part 1 challenges us to count the number of paths from a start node\nto an end node in a\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Directed_acyclic_graph"},"directed acyclic graph")," (DAG)."),(0,o.kt)("h4",{id:"input-modeling"},"Input Modeling"),(0,o.kt)("p",null,"We will model the input as an\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Adjacency_list"},"adjacency list"),"\nfrom each device to those to which it is connected:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type AdjacencyList = Map[String, List[String]]\n")),(0,o.kt)("p",null,"We can then add an extension method to ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," to parse the input.\nOne line at a time, we parse the start device and its connections,\nand then split the connections into a list:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"extension (self: String)\n  def parse: AdjacencyList = self.linesIterator\n    .collect:\n      case s\"$a: $b\" => a -> b.split(' ').toList\n    .toMap\n")),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'val a = "aaa: you hhh".parse\na: Map("aaa" -> List("you", "hhh"))\n')),(0,o.kt)("h4",{id:"counting-paths"},"Counting Paths"),(0,o.kt)("p",null,"Graph traversal is typically done with either\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"breadth-first search"),"\nor ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Depth-first_search"},"depth-first search"),".\nBreadth-first is appropriate for finding shortest paths and other\nsuch minima, typically with a short-cut exit, but can have significant\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Space_complexity"},"space complexity"),"\n(memory usage). In this case, we want to traverse all paths, so depth-first\nis more appropriate, having ",(0,o.kt)("em",{parentName:"p"},"O(log(N))")," space complexity."),(0,o.kt)("p",null,"To count the paths we will use a recursive loop:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of paths from ",(0,o.kt)("strong",{parentName:"li"},"B")," to ",(0,o.kt)("strong",{parentName:"li"},"B")," is 1."),(0,o.kt)("li",{parentName:"ul"},"The number of paths from ",(0,o.kt)("strong",{parentName:"li"},"A")," to ",(0,o.kt)("strong",{parentName:"li"},"B")," is equal to the sum of the\nnumber of paths from all nodes adjacent to ",(0,o.kt)("strong",{parentName:"li"},"A")," to ",(0,o.kt)("strong",{parentName:"li"},"B"),".")),(0,o.kt)("p",null,"We will implement this as an extension method on our ",(0,o.kt)("inlineCode",{parentName:"p"},"AdjacencyList"),"\ntype:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"extension (adjacency: AdjacencyList)\n  def countPaths(from: String, to: String): Long =\n    def loop(loc: String): Long =\n      if loc == to then 1L else adjacency(loc).map(loop).sum\n    loop(from)\n")),(0,o.kt)("p",null,"We use ",(0,o.kt)("inlineCode",{parentName:"p"},"Long")," as our result type; AoC is notorious for\nproblem that overflow the size of an ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),". This is not a\ntail-recursive loop because the recursive call is not the last statement."),(0,o.kt)("h4",{id:"solution"},"Solution"),(0,o.kt)("p",null,"With this framework in place, we can now easily solve part 1:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def part1(input: String): Long = input.parse.countPaths("you", "out")\n')),(0,o.kt)("h3",{id:"part-2"},"Part 2"),(0,o.kt)("p",null,"Part 2 asks us to again count the number of paths through a graph,\nbut this time from a different start location, and counting only\npaths that pass through two particular nodes (in any order)."),(0,o.kt)("p",null,"One might be tempted to approach this by keeping track of all the\nnodes through which we have traversed using a ",(0,o.kt)("inlineCode",{parentName:"p"},"Set[String]"),", and\nchecking for the two named nodes when we reach the end; or, indeed,\nby simply keeping track of whether we have encountered the two\nspecific nodes using two ",(0,o.kt)("inlineCode",{parentName:"p"},"Boolean"),"s.\nThis extra work is unnecessary, however, if you make the following\nobservation:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If there are ",(0,o.kt)("strong",{parentName:"li"},"n")," paths from ",(0,o.kt)("strong",{parentName:"li"},"A")," to ",(0,o.kt)("strong",{parentName:"li"},"B"),", and ",(0,o.kt)("strong",{parentName:"li"},"m")," paths\nfrom ",(0,o.kt)("strong",{parentName:"li"},"B")," to ",(0,o.kt)("strong",{parentName:"li"},"C"),", then there are ",(0,o.kt)("strong",{parentName:"li"},"n"),"\xd7",(0,o.kt)("strong",{parentName:"li"},"m")," paths from\n",(0,o.kt)("strong",{parentName:"li"},"A")," to ",(0,o.kt)("strong",{parentName:"li"},"C"),".")),(0,o.kt)("p",null,"To solve the problem, we then just need to consider two routes\nthrough the system:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"svr")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"fft")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"dac")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"out")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"svr")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"dac")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"fft")," \u2192\u22ef\u2192 ",(0,o.kt)("strong",{parentName:"li"},"out"))),(0,o.kt)("p",null,"For each option, we count the number of paths between each pair\nof nodes, take the product of those intermediate results, and then\nsum the two results. (Because this graph is acyclic, there in fact\ncannot be both a path ",(0,o.kt)("strong",{parentName:"p"},"fft")," \u21e2 ",(0,o.kt)("strong",{parentName:"p"},"dac")," and a path ",(0,o.kt)("strong",{parentName:"p"},"dac")," \u21e2 ",(0,o.kt)("strong",{parentName:"p"},"fft"),",\nso one of these values will be zero.)"),(0,o.kt)("h4",{id:"initial-solution"},"Initial Solution"),(0,o.kt)("p",null,"Our initial solution is to sum the solutions through these these two routes;\nwe split each route into pairs of nodes using ",(0,o.kt)("inlineCode",{parentName:"p"},"sliding(2)"),", count\nthe paths between these pairs, and take the product of those values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def part2(input: String): Long =\n  val adjacency = input.parse.withDefaultValue(Nil)\n  List("svr-dac-fft-out", "svr-fft-dac-out")\n    .map: route =>\n      route\n        .split(\'-\')\n        .sliding(2)\n        .map: pair =>\n          adjacency.countPaths(pair(0), pair(1))\n        .product\n    .sum\n')),(0,o.kt)("p",null,"Note one small addition; we add a default value of ",(0,o.kt)("inlineCode",{parentName:"p"},"Nil"),"\n(the empty list) to our adjacency list, to easily accommodate\nroutes that do not terminate at the ",(0,o.kt)("strong",{parentName:"p"},"out")," node."),(0,o.kt)("h5",{id:"the-problem"},"The Problem"),(0,o.kt)("p",null,"It rapidly becomes clear that this solution will not complete\nwithin any reasonable time. If ",(0,o.kt)("strong",{parentName:"p"},"A")," is connected to both ",(0,o.kt)("strong",{parentName:"p"},"B")," and ",(0,o.kt)("strong",{parentName:"p"},"C"),",\nand both of those are connected to both ",(0,o.kt)("strong",{parentName:"p"},"D")," and ",(0,o.kt)("strong",{parentName:"p"},"E"),", and so on,\nthen the number of paths we have to traverse will grow exponentially.\nWe did not encounter this in part 1 because the problem was constructed\nsuch that there was no exponential growth from that other starting point."),(0,o.kt)("h4",{id:"memoization"},"Memoization"),(0,o.kt)("p",null,"The solution to this problem is\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Memoization"},"memoization"),". In the problem\ndescribed just above, when we are counting the number of paths from ",(0,o.kt)("strong",{parentName:"p"},"B"),", we\nhave to count number of paths from ",(0,o.kt)("strong",{parentName:"p"},"D")," and ",(0,o.kt)("strong",{parentName:"p"},"E"),". When we are then looking\nat ",(0,o.kt)("strong",{parentName:"p"},"C"),", we have already calculated the results for ",(0,o.kt)("strong",{parentName:"p"},"D")," and ",(0,o.kt)("strong",{parentName:"p"},"E"),"\nso we don't need to repeat those calculations. If we store every\nintermediate result, we can avoid the exponential growth."),(0,o.kt)("p",null,"To apply this fix, we can use a ",(0,o.kt)("inlineCode",{parentName:"p"},"mutable.Map")," as a memo to store these\nintermediate values inside our ",(0,o.kt)("inlineCode",{parentName:"p"},"countPaths")," function. The logic we want\nbasically looks like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  def countPaths(from: String, to: String): Long =\n    val memo = mutable.Map.empty[String, Long]\n    def loop(loc: String): Long =\n      if memo.contains(loc) then memo(loc)\n      else\n        val count = if loc == to then 1L else adjacency(loc).map(loop).sum\n        memo.update(loc, count)\n        count\n    loop(from)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"mutable.Map")," class provides a ",(0,o.kt)("inlineCode",{parentName:"p"},"getOrElseUpdate")," method that\nallows us to efficiently and cleanly express this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  def countPaths(from: String, to: String): Long =\n    val memo                    = mutable.Map.empty[String, Long]\n    def loop(loc: String): Long =\n      lazy val count if loc == to then 1L else adjacency(loc).map(loop).sum\n      memo.getOrElseUpdate(loc, count)\n    loop(from)\n")),(0,o.kt)("p",null,"We use a ",(0,o.kt)("inlineCode",{parentName:"p"},"lazy val")," just for clarity here. The second parameter to\n",(0,o.kt)("inlineCode",{parentName:"p"},"getOrElseUpdate")," is a\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/tour/by-name-parameters.html"},"by-name parameter"),",\nso the ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," computation will only be evaluated if the key is not already\npresent in the map."),(0,o.kt)("p",null,"With this enhancement, the computation completes in moments and the\nresult is very large \u2013 almost a quadrillion in my case. Without\nmemoization, the universe would be a distant memory before the initial\nsolution would complete."),(0,o.kt)("h2",{id:"on-mutability"},"On Mutability"),(0,o.kt)("p",null,"As someone (although apparently not on the Internet) once said:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u201cAbjure mutability, embrace purity and constancy\u201d")),(0,o.kt)("p",null,"Mutability is absolutely necessary in order to efficiently solve\nmany problems. But, like children, it is best kept in a small\nroom under the stairs."),(0,o.kt)("p",null,"Oftentimes we seek to encapsulate mutability\nin library helper functions, to avoid sullying our day to day code.\nWe can do just the same here."),(0,o.kt)("p",null,"If you consider the ",(0,o.kt)("inlineCode",{parentName:"p"},"loop")," function inside ",(0,o.kt)("inlineCode",{parentName:"p"},"countPaths"),": It takes an\ninput parameter of type ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," (",(0,o.kt)("inlineCode",{parentName:"p"},"String")," in this case) and produces an\noutput of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Result")," (",(0,o.kt)("inlineCode",{parentName:"p"},"Long")," in this case), and is called with an\ninitial value (",(0,o.kt)("inlineCode",{parentName:"p"},"from"),"). As part of its operation, it needs to be able\nto recursively call itself."),(0,o.kt)("p",null,"Consider now the following ",(0,o.kt)("inlineCode",{parentName:"p"},"memoized")," function signature: It has the same two\ntype parameters, ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Result"),", an initial value ",(0,o.kt)("inlineCode",{parentName:"p"},"init"),",\nand a function from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Result")," \u2013 but this function has a second\nparameter, a function from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Result")," (the recursion call) \u2013\nand it returns a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Result"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def memoized[A, Result](init: A)(f: (A, A => Result) => Result): Result\n")),(0,o.kt)("p",null,"With something like this, we can rewrite ",(0,o.kt)("inlineCode",{parentName:"p"},"countPaths")," just so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  def countPaths(from: String, to: String): Long =\n    memoized[Result = Long](from): (loc, loop) =>\n      if loc == to then 1L else adjacency(loc).map(loop).sum\n")),(0,o.kt)("p",null,"If you squint, this is now almost identical to the non-memoized\ncode. Our shameful mutability is hidden."),(0,o.kt)("p",null,"This uses ",(0,o.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/reference/experimental/named-typeargs.html"},"named type arguments"),",\nan experimental language feature that lets us avoid specifying\nboth types. In this case, the result type can't be automatically inferred."),(0,o.kt)("p",null,"And what does ",(0,o.kt)("inlineCode",{parentName:"p"},"memoized")," look like? It creates a ",(0,o.kt)("inlineCode",{parentName:"p"},"Function1"),"\nclass that encapsulates the memo and allows the recursive function\nto be called, like the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator"},"Y combinator"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def memoized[A, Result](init: A)(f: (A, A => Result) => Result): Result =\n  class Memoize extends (A => B):\n    val memo = mutable.Map.empty[A, B]\n    def apply(a: A): B = memo.getOrElseUpdate(a, f(a, this))\n  Memoize()(init)\n")),(0,o.kt)("h2",{id:"final-code"},"Final Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'def part1(input: String): Long = input.parse.countPaths("you", "out")\n\ndef part2(input: String): Long =\n  val adjacency = input.parse.withDefaultValue(Nil)\n  List("svr-dac-fft-out", "svr-fft-dac-out")\n    .map: route =>\n      route\n        .split(\'-\')\n        .sliding(2)\n        .map: pair =>\n          adjacency.countPaths(pair(0), pair(1))\n        .product\n    .sum\n\ntype AdjacencyList = Map[String, List[String]]\n\nimport scala.language.experimental.namedTypeArguments\n\nextension (adjacency: AdjacencyList)\n  def countPaths(from: String, to: String): Long =\n    memoized[Result = Long](from): (loc, loop) =>\n      if loc == to then 1L else adjacency(loc).map(loop).sum\n\ndef memoized[A, Result](init: A)(f: (A, A => Result) => Result): Result =\n  class Memoize extends (A => B):\n    val memo = mutable.Map.empty[A, B]\n    def apply(a: A): B = memo.getOrElseUpdate(a, f(a, this))\n  Memoize()(init)\n\nextension (self: String)\n  def parse: AdjacencyList = self.linesIterator\n    .collect:\n      case s"$a: $b" => a -> b.split(\' \').toList\n    .toMap\n')),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/11/solution.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"p",href:"https://nichobi.com"},"nichobi"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day11.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/philippus"},"Philippus Baalman"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2025/day11.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/merlinorg/"},"merlin"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day11"},"Solution")," by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk")))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}u.isMDXComponent=!0}}]);