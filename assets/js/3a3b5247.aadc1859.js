"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9459],{8709:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var n=a(7462),l=(a(7294),a(3905));a(6340);const s={},o="Day 12: Christmas Tree Farm",i={unversionedId:"2025/puzzles/day12",id:"2025/puzzles/day12",title:"Day 12: Christmas Tree Farm",description:"by @natsukagami",source:"@site/target/mdoc/2025/puzzles/day12.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day12",permalink:"/scala-advent-of-code/2025/puzzles/day12",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day12.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 11: Reactor",permalink:"/scala-advent-of-code/2025/puzzles/day11"},next:{title:"Day 1: Historian Hysteria",permalink:"/scala-advent-of-code/2024/puzzles/day01"}},r={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Inspecting the input",id:"inspecting-the-input",level:2},{value:"Bonus: Can Z3 solve it?",id:"bonus-can-z3-solve-it",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-12-christmas-tree-farm"},"Day 12: Christmas Tree Farm"),(0,l.kt)("p",null,"by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/natsukagami"},"@natsukagami")),(0,l.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/12"},"https://adventofcode.com/2025/day/12")),(0,l.kt)("h2",{id:"inspecting-the-input"},"Inspecting the input"),(0,l.kt)("p",null,"Today's problem gives us various shapes contained in a 3x3 box, and asks us whether we can place them in a larger MxN space.\nThe number of shapes of each kind is given."),(0,l.kt)("p",null,"This is eerily reminiscent of the ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bin_packing_problem"},"Bin Packing problem"),", therefore we should\nexpect to figure out some patterns in the input, as the general problem is likely to be untractable."),(0,l.kt)("p",null,"We are given the following 6 shapes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0:\n###\n##.\n##.\n\n1:\n###\n##.\n.##\n\n2:\n.##\n###\n##.\n\n3:\n##.\n###\n##.\n\n4:\n###\n#..\n###\n\n5:\n###\n.#.\n###\n")),(0,l.kt)("p",null,"Note that they can be rotated and flipped, so the total number of shapes is actually about 72."),(0,l.kt)("p",null,"The input asks for spaces of size ~2000 (at 40-50 cells for each edge), with the total amount of shapes hovering around a few hundreds, so simply backtracking is not possible (but we tried anyway!)."),(0,l.kt)("p",null,"However, we can weed out some special cases:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the space given is spacious enough to fit each shape in its own 3x3 box (i.e. without fitting them together), we can trivially place them:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def triviallyPossible(maxRows: Int, maxCols: Int, requirements: Map[Shape, Int]) =\n  val totalCount = requirements.values.sum // total number of required shapes\n  (maxRows / 3) * (maxCols / 3) >= totalCount\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the space given is ",(0,l.kt)("em",{parentName:"p"},"not enough to fit the total number of cells occupied by the shapes"),", then no matter how we fit them, we cannot fit all the shapes into the given space:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Shape(cells: Array[Array[Char]]):\n  def cellCount =\n    cells\n      .iterator\n      .map(row => row.count(_ == '#'))\n      .sum\n\ndef triviallyImpossible(maxRows: Int, maxCols: Int, requirements: Map[Shape, Int]) =\n  val totalCellCount =\n    requirements\n      .iterator\n      .map((shape, count) => shape.cellCount * count)\n      .sum\n  maxRows * maxCols < totalCellCount\n")))),(0,l.kt)("p",null,"Fortunately, ",(0,l.kt)("strong",{parentName:"p"},"all of our input queries fall into one of these categories!")," Therefore, we avoid endless search and grab our last star of the year. Cheers!"),(0,l.kt)("h2",{id:"bonus-can-z3-solve-it"},"Bonus: Can Z3 solve it?"),(0,l.kt)("p",null,"I have always heard that these NP-complete problems can sometimes be quickly solved by a general purpose SMT solving library, such as ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/Z3Prover/z3"},"Z3"),".\nIn a nutshell: SMT solvers like Z3 allow us to find solutions to inequalities (called ",(0,l.kt)("em",{parentName:"p"},"constraints")," in SMT terms) with multiple variables. So, if we manage to encode the problem as a set of arithmetic inequalities, then perhaps Z3 would give us the answer?"),(0,l.kt)("p",null,"To use Z3 from Scala, I opted for the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/epfl-lara/ScalaZ3"},"ScalaZ3")," wrapper made by EPFL's LARA lab.\nUnfortunately the library seems to not be able on Maven, so I compiled it myself and manually include it as an unmanaged JAR.\nIt was painless to compile however (",(0,l.kt)("inlineCode",{parentName:"p"},"sbt +package")," as the README says does the job), and including it is a single directive with the ",(0,l.kt)("inlineCode",{parentName:"p"},"scala")," command-line as a build tool:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"//> using jar ./scalaz3_3-4.8.14.jar\n")),(0,l.kt)("p",null,"In the code, we can set up a Z3 context as follows, preparing to build our constraints."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},'import z3.scala.*\nval ctx = new Z3Context("MODEL" -> true) // this allows us to receive a specific solution later on\nval i = ctx.mkIntSort()                  // declare an int-like type in the SMT context\n// some constants that we shall mention later\nval zero = ctx.mkInt(0, i)\nval one = ctx.mkInt(1, i)\n\n// as we will build up the complex constraints one-by-one, mutable collections make them easier to work with\nval constraints = mutable.ListBuffer[Z3AST]()\n')),(0,l.kt)("p",null,"Now, how do we encode our problem as a bunch of arithmetic inequalities? From a glance, here are the requirements that we have\nto encode:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For shape ",(0,l.kt)("inlineCode",{parentName:"li"},"i"),", we have to use ",(0,l.kt)("inlineCode",{parentName:"li"},"count(i)")," amount of shapes."),(0,l.kt)("li",{parentName:"ul"},"The shapes should be laid on a ",(0,l.kt)("inlineCode",{parentName:"li"},"N x M")," space."),(0,l.kt)("li",{parentName:"ul"},"Layered shapes should not overlap.")),(0,l.kt)("p",null,"A simple way to encode the ",(0,l.kt)("em",{parentName:"p"},"choice")," of putting a shape at a specific position, is to turn them into a ",(0,l.kt)("em",{parentName:"p"},"binary variable"),".\nFor shape ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," and a location for the top-left corner ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, y)"),", we would put ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," at this location if the variable ",(0,l.kt)("inlineCode",{parentName:"p"},"v(i, x, y)"),"\nholds true.\nAs we shall be working with Z3's integers (we will see why later), we will add the following constraints to our list:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v(i, x, y) >= 0")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v(i, x, y) <= 1"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Variable(shape: Shape, ti: Int, tj: Int, variable: Z3AST)\n\ndef setupShape(shape: Shape): Seq[Variable] =\n  val vars = for\n        s <- shape.allRotationsAndFlips\n        # every possible top-left corners\n        ti <- 0 to maxRows - shape.rows\n        tj <- 0 to maxCols - shape.cols\n    yield\n      // create a new variable of type `i`, this is our v(i, x, y)\n      val v = ctx.mkConst(ctx.mkFreshStringSymbol(), i)\n      constraints ++= Seq(\n        ctx.mkGE(v, zero), // v >= 0\n        ctx.mkLE(v, one)   // v <= 1\n      )\n      Variable(s, ti, tj, v)\n")),(0,l.kt)("p",null,"That was simple! Either we put the shape, or we don't.\nNow, we can easily encode the first requirement: simply require that the ",(0,l.kt)("em",{parentName:"p"},"sum")," of all our binary variables for every position\nof shape ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," to be equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"count(i)")," itself:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"  constraints += ctx.mkEq(\n    ctx.mkAdd(vars*), // sum of all our variables above\n    requirements(shape)\n  )\n")),(0,l.kt)("p",null,"Incidentally, since we encoded the fact that we put them at only valid locations, the second requirement is already satisfied!"),(0,l.kt)("p",null,"The last requirement is that every cell is only filled at most once.\nTo see how we could encode this, let's look at how a certain ",(0,l.kt)("inlineCode",{parentName:"p"},"v(i, x, y)")," affects the filled space.\nLet's say we try to fit the 4th shape to location (2, 3):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"\\0123456\n0.......\n1.......\n2...###.\n3...#...\n4...###.\n5.......\n")),(0,l.kt)("p",null,"It affects cells (2,3), (2,4), (2,5), (3,3), (4,3), (4,4) and (4,5). So, if cell ",(0,l.kt)("inlineCode",{parentName:"p"},"(p, q)")," in the shape is filled, then\ncell ",(0,l.kt)("inlineCode",{parentName:"p"},"(x + p, y + q)")," would be filled in our space! We would say that ",(0,l.kt)("inlineCode",{parentName:"p"},"v(4, 2, 3)"),' would "contribute" to all cells\n(2,3), (2,4), (2,5), (3,3), (4,3), (4,4) and (4,5).'),(0,l.kt)("p",null,'Let\'s try to construct the list of all possible "contributors" for each cell:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"// defined globally and mutable ;)\nval contributors = Array.fill(maxRows, maxCols)(mutable.ListBuffer[Z3AST]())\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Z3AST")," is the type of a constraint in Z3: it is a syntax node of the larger constraint expression."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"      // in the setupShape function, in our vars for expression\n      for i <- 0 until s.rows\n          j <- 0 until s.cols\n          if shape.isFilled(i, j)\n      do\n        contributors(ti + i)(tj + j) += v\n")),(0,l.kt)("p",null,"Once all the contributors have been found, we simply require that ",(0,l.kt)("em",{parentName:"p"},"at most one")," of the contributors can actually be filled.\nIn terms of arithmetic, we can require that the ",(0,l.kt)("em",{parentName:"p"},"sum")," of the contributors is at most 1, so at most one of the contributors can be one."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"constraints ++=\n  for i <- 0 until maxRows\n      j <- 0 until maxCols\n      cs = contributors(i)(j) // contributors to cell (i, j)\n      if !cs.isEmpty\n  yield ctx.mkLE( // <=\n    ctx.mkAdd(cs.toSeq*), // sum of all the contributors\n    one\n  )\n")),(0,l.kt)("p",null,"And that's it! We just have to summon the solver, and asks whether it can find a solution."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"val solver = ctx.mkSolver()\nsolver.assertCnstr(\n  ctx.mkAnd(constraints.toSeq*), // require all our constraints to be true\n)\nsolver.check().get // will fail if Z3 time outs before finding a solution\n")),(0,l.kt)("p",null,"Also, we can ask Z3 to find one specific solution for us:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"solver\n  .checkAndGetAllModels()\n  .nextOption()\n  .map: model =>\n    val toFill =\n      variables // the Seq of all variables for all shapes\n      .filter:\n        case Variable(shape, ti, tj, v) =>\n          model.evalAs[Int](v) == 1\n    // we can now draw shapes in toFill down!\n")),(0,l.kt)("p",null,"So, how does this fare?"),(0,l.kt)("p",null,"Well, Z3 can solve the example... (that the trivial code cannot)"),(0,l.kt)("p",null,"But no luck for any tests in the actual input :( So yes, it was fun, but we still created tens of thousands of variables, and solvers still cannot deal with that much yet."),(0,l.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"https://github.com/rmarbeck/advent2025/blob/main/day12/src/main/scala/Solution.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day12.scala"},"Solution")," by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/philippus"},"Philippus Baalman"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day12"},"Solution")," by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"https://gist.github.com/AlexITC/aa893a5a32d01f4e59c0adbd0732c8c9"},"Solution")," by ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/AlexITC"},"Alexis Hernandez")))),(0,l.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}u.isMDXComponent=!0}}]);