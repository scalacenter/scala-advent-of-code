"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5010],{8914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var a=n(7462),i=(n(7294),n(3905));n(6340);const l={},s="Day 7: Laboratories",o={unversionedId:"2025/puzzles/day07",id:"2025/puzzles/day07",title:"Day 7: Laboratories",description:"by @aamiguet",source:"@site/target/mdoc/2025/puzzles/day07.md",sourceDirName:"2025/puzzles",slug:"/2025/puzzles/day07",permalink:"/scala-advent-of-code/2025/puzzles/day07",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2025/puzzles/day07.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 6: Trash Compactor",permalink:"/scala-advent-of-code/2025/puzzles/day06"},next:{title:"Day 8: Playground",permalink:"/scala-advent-of-code/2025/puzzles/day08"}},p={},r=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Parsing the input",id:"parsing-the-input",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:r};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-7-laboratories"},"Day 7: Laboratories"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/aamiguet/"},"@aamiguet")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2025/day/7"},"https://adventofcode.com/2025/day/7")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Parse the input representing the faulty tachyon manifold into an ",(0,i.kt)("inlineCode",{parentName:"li"},"Array")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"String"),"."),(0,i.kt)("li",{parentName:"ul"},"In part 1, we count the number of times a tachyon beam is split."),(0,i.kt)("li",{parentName:"ul"},"In part 2, we count all the possible timelines (paths) a tachyon can take in the manifold.")),(0,i.kt)("h2",{id:"parsing-the-input"},"Parsing the input"),(0,i.kt)("p",null,"Parsing the input is quite straighforward. First let's define a type alias so that we have a meaningful type name for our value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Manifold = Array[String]\n")),(0,i.kt)("p",null,"As the input is a multiline ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," with each line representing a row of the manifold, we simply split it by lines:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'private def parse(input: String): Manifold =\n  input.split("\\n")\n')),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"We have to count the number of times a beam is split. A split occurs when a beam hits a splitter ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," at position ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," . The beam is then split and continue at position ",(0,i.kt)("inlineCode",{parentName:"p"},"i - 1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"i + 1")," in the next row (line) of the manifold."),(0,i.kt)("p",null,"We process the manifold in the direction of the beam, top to bottom, row by row. For each row, we have to do two things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Count the number of splitters hit by a beam"),(0,i.kt)("li",{parentName:"ul"},"Update the positions of the beam for the next row")),(0,i.kt)("p",null,"Let's first parse our manifold and find the initial position of the beam:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val manifold = parse(input)\nval beamSource = Set(manifold.head.indexOf('S'))\n")),(0,i.kt)("p",null,"We then iterate over all the remaining rows using ",(0,i.kt)("inlineCode",{parentName:"p"},"foldLeft"),". Our initial value is composed of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," containing the index of the source of the beam and an initial split count of 0."),(0,i.kt)("p",null,"At each step we update both the positions of the beam and the cumulative split count and finally return the final count."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"manifold\n  .tail\n  .foldLeft((beamSource, 0)):\n    case ((beamIndices, splitCount), row) =>\n      val splitIndices = findSplitIndices(row, beamIndices)\n      val updatedBeamIndices =\n        beamIndices ++ splitIndices.flatMap(i => Set(i - 1, i + 1)) -- splitIndices\n      (updatedBeamIndices, splitCount + splitIndices.size)\n  ._2\n")),(0,i.kt)("p",null,"The heavy lifting is done by:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val splitIndices = findSplitIndices(row, beamIndices)\nval updatedBeamIndices =\n  beamIndices ++ splitIndices.flatMap(i => Set(i - 1, i + 1)) -- splitIndices\n(updatedBeamIndices, splitCount + splitIndices.size)\n")),(0,i.kt)("p",null,"First we find all the indices where a hit occurs between a beam and a splitter. This is done in the function ",(0,i.kt)("inlineCode",{parentName:"p"},"findSplitIndices"),"."),(0,i.kt)("p",null,"This function takes two arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"row")," : the current row of the manifold"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"beamIndices")," : the resulting ",(0,i.kt)("inlineCode",{parentName:"li"},"Set")," of beam indices from the previous row")),(0,i.kt)("p",null,"We use the fact that a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," acts like an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array[Char]"),". We zip it with its index and filter it with two conditions :"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A beam is travelling at this index"),(0,i.kt)("li",{parentName:"ul"},"There is a splitter at this index")),(0,i.kt)("p",null,"The function returns the list of indices as we don't need anything else."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"private def findSplitIndices(row: String, beamIndices: Set[Int]): List[Int] =\n  row\n    .zipWithIndex\n    .filter: (location, i) =>\n      beamIndices(i) && location == '^'\n    .map(_._2)\n    .toList\n")),(0,i.kt)("p",null,"We now have everything we need for the next step :"),(0,i.kt)("p",null,"From the previous beam indices we compute the new beam indices ",(0,i.kt)("inlineCode",{parentName:"p"},"updatedBeamIndices"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Add the split beam indices : to the right and to the left of each split index."),(0,i.kt)("li",{parentName:"ul"},"Remove the ",(0,i.kt)("inlineCode",{parentName:"li"},"splitIndices")," as the beam is discontinued after a splitter.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val updatedBeamIndices =\n  beamIndices ++ splitIndices.flatMap(i => Set(i - 1, i + 1)) -- splitIndices\n")),(0,i.kt)("p",null,"And update the cumulative split count, as ",(0,i.kt)("inlineCode",{parentName:"p"},"splitIndices")," contains only the indices where a splitter is hit, it's simply:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"splitCount + splitIndices.size\n")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"In part 2, we are tasked to count all the possible timelines (paths) a single tachyon can take in the manifold."),(0,i.kt)("p",null,"The problem in itself is not much different than part 1 but it has some pitfalls."),(0,i.kt)("p",null,"We could try to exhaustively compute all the possible paths and count them, but that would be time consuming as the manifold is quite big. Everytime a tachyon hits a splitter, the number of possible futures for this tachyon is doubled!"),(0,i.kt)("p",null,"But we can actually count the number without knowing everything path. To do so we use the following property: all the tachyons reaching a given position ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," at a row ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," share the same future timelines. So we don't need to know their past timelines but only the number of tachyons for each position at each step."),(0,i.kt)("p",null,"Like in part 1, we parse the manifold and find the original position of the tachyon."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val manifold = parse(input)\nval beamTimelineSource = Map(manifold.head.indexOf('S') -> 1L)\n")),(0,i.kt)("p",null,"Once more we use ",(0,i.kt)("inlineCode",{parentName:"p"},"foldLeft")," to iterate over the manifold. Our accumulator is now the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," counting the number of timelines for each tachyon position. Its initial value is the count of the single path the tachyon has taken from the source."),(0,i.kt)("p",null,"Finally we return the sum of all the timelines count."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"manifold\n  .tail\n  .foldLeft(beamTimelineSource): (beamTimelines, row) =>\n    val splitIndices = findSplitIndices(row, beamTimelines.keySet)\n    val splitTimelines =\n      splitIndices\n        .flatMap: i =>\n          val pastTimelines = beamTimelines(i)\n          List((i + 1) -> pastTimelines, (i - 1) -> pastTimelines)\n        .groupMap(_._1)(_._2)\n        .view\n        .mapValues(_.sum)\n        .toMap\n    val updatedBeamTimelines =\n      splitTimelines\n        .foldLeft(beamTimelines): (bm, s) =>\n          bm.updatedWith(s._1):\n            case None => Some(s._2)\n            case Some(n) => Some(n + s._2)\n        .removedAll(splitIndices)\n    updatedBeamTimelines\n  .values\n  .sum\n")),(0,i.kt)("p",null,"Let's dive into it!"),(0,i.kt)("p",null,"First, we reuse ",(0,i.kt)("inlineCode",{parentName:"p"},"findSplitIndices")," from part 1 to find the splits."),(0,i.kt)("p",null,"Then we compute the new timelines originating from each split. Every time a tachyon hits a splitter two new timelines are created: one to the left and one to the right of the splitter. This doubles the number of timelines. Example:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If a tachyon with 3 different past timelines hits a splitter at position ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", in the next step we have two possible tachyons with each 3 different past timelines at position ",(0,i.kt)("inlineCode",{parentName:"p"},"i - 1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"i + 1")," making a total of 6 timelines.")),(0,i.kt)("p",null,"Since we don't care about the past timelines but only the current positions: if multiple splits lead to the same tachyon position, we can group them and sum count of the past timelines which is done by applying ",(0,i.kt)("inlineCode",{parentName:"p"},"groupMap")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mapValues")," to the resulting ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),"."),(0,i.kt)("p",null,"Overall this is implemented with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val splitTimelines =\n  splitIndices\n    .flatMap: i =>\n      // splitting a timeline\n      val pastTimelines = beamTimelines(i)\n      List((i + 1) -> pastTimelines, (i - 1) -> pastTimelines)\n    // grouping and summing timelines by resulting position\n    .groupMap(_._1)(_._2)\n    .view\n    .mapValues(_.sum)\n    .toMap\n")),(0,i.kt)("p",null,"From the previous beam timelines map we finally compute the new beam timelines ",(0,i.kt)("inlineCode",{parentName:"p"},"updatedBeamTimelines"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Merging the split timelines ",(0,i.kt)("inlineCode",{parentName:"li"},"Map"),". By using ",(0,i.kt)("inlineCode",{parentName:"li"},"updateWith")," we handle the two cases:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If the entry already exists, we udpate it by adding the new timeline count to the existing one"),(0,i.kt)("li",{parentName:"ul"},"Or creating a new entry"))),(0,i.kt)("li",{parentName:"ul"},"Removing all positions that hit a splitter")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val updatedBeamTimelines =\n  splitTimelines\n    .foldLeft(beamTimelines): (bm, s) =>\n      bm.updatedWith(s._1):\n        // adding a new key\n        case None => Some(s._2)\n        // updating a value by summing both timeline counts\n        case Some(n) => Some(n + s._2)\n    .removedAll(splitIndices)\n")),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Manifold = Array[String]\n\nprivate def parse(input: String): Manifold =\n  input.split(\"\\n\")\n\nprivate def findSplitIndices(row: String, beamIndices: Set[Int]): List[Int] =\n  row\n    .zipWithIndex\n    .filter: (location, i) =>\n      beamIndices(i) && location == '^'\n    .map(_._2)\n    .toList\n\noverride def part1(input: String): Long =\n  val manifold = parse(input)\n  val beamSource = Set(manifold.head.indexOf('S'))\n  manifold\n    .tail\n    .foldLeft((beamSource, 0)):\n      case ((beamIndices, splitCount), row) =>\n        val splitIndices = findSplitIndices(row, beamIndices)\n        val updatedBeamIndices =\n          beamIndices ++ splitIndices.flatMap(i => Set(i - 1, i + 1)) -- splitIndices\n        (updatedBeamIndices, splitCount + splitIndices.size)\n    ._2\n\noverride def part2(input: String): Long =\n  val manifold = parse(input)\n  val beamTimelineSource = Map(manifold.head.indexOf('S') -> 1L)\n  manifold\n    .tail\n    .foldLeft(beamTimelineSource): (beamTimelines, row) =>\n      val splitIndices = findSplitIndices(row, beamTimelines.keySet)\n      val splitTimelines =\n        splitIndices\n          .flatMap: i =>\n            val pastTimelines = beamTimelines(i)\n            List((i + 1) -> pastTimelines, (i - 1) -> pastTimelines)\n          .groupMap(_._1)(_._2)\n          .view\n          .mapValues(_.sum)\n          .toMap\n      val updatedBeamTimelines =\n        splitTimelines\n          .foldLeft(beamTimelines): (bm, s) =>\n            bm.updatedWith(s._1):\n              case None => Some(s._2)\n              case Some(n) => Some(n + s._2)\n          .removedAll(splitIndices)\n      updatedBeamTimelines\n    .values\n    .sum\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2025/blob/main/day07/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2025/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic/advent-of-code-2025/blob/main/d7/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/henryk-cesnolovic"},"Henryk \u010cesnolovi\u010d")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi/adventofcode/src/branch/main/2025/07/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://codeberg.org/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2025/day07/DaySeven.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2025/src/main/scala/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"Yann Moisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2025/blob/master/src/main/scala/day07/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2025/blob/main/src/main/scala/ch/aamiguet/advent2025/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2025/tree/main/src/main/scala/day7"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/842"},"Go here to volunteer")))}d.isMDXComponent=!0}}]);