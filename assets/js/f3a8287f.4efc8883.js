"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3210],{4328:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));n(6340);const r={},o="Day 23: LAN Party",l={unversionedId:"2024/puzzles/day23",id:"2024/puzzles/day23",title:"Day 23: LAN Party",description:"by @scarf005",source:"@site/target/mdoc/2024/puzzles/day23.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day23",permalink:"/scala-advent-of-code/2024/puzzles/day23",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day23.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 22: Monkey Market",permalink:"/scala-advent-of-code/2024/puzzles/day22"},next:{title:"Day 24: Crossed Wires",permalink:"/scala-advent-of-code/2024/puzzles/day24"}},s={},c=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Parsing the input",id:"parsing-the-input",level:2},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final code",id:"final-code",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-23-lan-party"},"Day 23: LAN Party"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scarf005"},"@scarf005")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/23"},"https://adventofcode.com/2024/day/23")),(0,i.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,i.kt)("p",null,"The puzzle involves finding triangles and ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Clique_(graph_theory)"},"maximal cliques"),". The task is to determine:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Part 1"),": Find the number of triangles in the graph."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Part 2"),": Find the size of the largest clique in the graph.")),(0,i.kt)("h2",{id:"parsing-the-input"},"Parsing the input"),(0,i.kt)("p",null,"Both parts use undirected graphs, represented as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type Connection = Map[String, Set[String]]\n\ndef parse(input: String): Connection = input\n  .split('\\n')\n  .toSet\n  .flatMap { case s\"$a-$b\" => Set(a -> b, b -> a) } // 1)\n  .groupMap(_._1)(_._2)                             // 2)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1)"),": both ",(0,i.kt)("inlineCode",{parentName:"li"},"a -> b")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b -> a")," are added to the graph so that the graph is undirected."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2)"),": a fancier way to write ",(0,i.kt)("inlineCode",{parentName:"li"},"groupBy(_._1).mapValues(_.map(_._2))"),", ",(0,i.kt)("a",{parentName:"li",href:"https://www.scala-lang.org/api/3.x/scala/collection/IterableOps.html#groupMap-fffff03a"},"check the docs")," for details.")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"The goal is to find triangles that have a computer whose name starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"t"),".\nThis could be checked by simply checking whether all three vertices are connected to each other, like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// connection: Connection\n\nextension (a: String)\n  inline infix def <->(b: String) =\n    connection(a).contains(b) && connection(b).contains(a)\n\ndef isValidTriangle(vertices: Set[String]): Boolean = vertices.toList match\n  case List(a, b, c) => a <-> b && b <-> c && c <-> a\n  case _             => false\n")),(0,i.kt)("p",null,"Then it's just a matter of getting all neighboring vertices of each vertex and checking if they form a triangle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part1(input: String) =\n  val connection = parse(input)\n\n  extension (a: String)\n    inline infix def <->(b: String) =\n      connection(a).contains(b) && connection(b).contains(a)\n\n  def isValidTriangle(vertices: Set[String]): Boolean = vertices.toList match\n    case List(a, b, c) => a <-> b && b <-> c && c <-> a\n    case _             => false\n\n  connection\n    .flatMap { (vertex, neighbors) =>\n      neighbors\n        .subsets(2)                               // 1)\n        .map(_ + vertex)                          // 2)\n        .withFilter(_.exists(_.startsWith("t")))\n        .filter(isValidTriangle)\n    }\n    .toSet\n    .size\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1)"),": chooses two neighbors..."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2)")," ...and adds the vertex itself to form a triangle.")),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"This part is more complex, but there's a generalization of the problem: ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Clique_(graph_theory)"},"finding the size of the largest clique in the graph"),". We'll skip the explanation of the algorithm, but here's the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def findMaximumCliqueBronKerbosch(connections: Connection): Set[String] =\n  def bronKerbosch(\n    potential: Set[String],\n    excluded: Set[String] = Set.empty,\n    result: Set[String] = Set.empty,\n  ): Set[String] =\n    if (potential.isEmpty && excluded.isEmpty) then result\n    else\n      // Choose pivot to minimize branching\n      val pivot = (potential ++ excluded)\n        .maxBy(vertex => potential.count(connections(vertex).contains))\n\n      val remaining = potential -- connections(pivot)\n\n      remaining.foldLeft(Set.empty[String]) { (currentMax, vertex) =>\n        val neighbors = connections(vertex)\n        val newClique = bronKerbosch(\n          result = result + vertex,\n          potential = potential & neighbors,\n          excluded = excluded & neighbors,\n        )\n        if (newClique.size > currentMax.size) newClique else currentMax\n      }\n\n  bronKerbosch(potential = connections.keySet)\n")),(0,i.kt)("p",null,"Then we could map them over to get the password:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def part2(input: String) =\n  val connection = parse(input)\n  findMaximumCliqueBronKerbosch(connection).toList.sorted.mkString(",")\n')),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'type Connection = Map[String, Set[String]]\n\ndef parse(input: String): Connection = input\n  .split(\'\\n\')\n  .toSet\n  .flatMap { case s"$a-$b" => Set(a -> b, b -> a) }\n  .groupMap(_._1)(_._2)\n\ndef part1(input: String) =\n  val connection = parse(input)\n\n  extension (a: String)\n    inline infix def <->(b: String) =\n      connection(a).contains(b) && connection(b).contains(a)\n\n  def isValidTriangle(vertices: Set[String]): Boolean = vertices.toList match\n    case List(a, b, c) => a <-> b && b <-> c && c <-> a\n    case _             => false\n\n  connection\n    .flatMap { (vertex, neighbors) =>\n      neighbors\n        .subsets(2)\n        .map(_ + vertex)\n        .withFilter(_.exists(_.startsWith("t")))\n        .filter(isValidTriangle)\n    }\n    .toSet\n    .size\n\ndef part2(input: String) =\n  val connection = parse(input)\n  findMaximumCliqueBronKerbosch(connection).toList.sorted.mkString(",")\n\ndef findMaximumCliqueBronKerbosch(connections: Connection): Set[String] =\n  def bronKerbosch(\n    potential: Set[String],\n    excluded: Set[String] = Set.empty,\n    result: Set[String] = Set.empty,\n  ): Set[String] =\n    if (potential.isEmpty && excluded.isEmpty) then result\n    else\n      // Choose pivot to minimize branching\n      val pivot = (potential ++ excluded)\n        .maxBy(vertex => potential.count(connections(vertex).contains))\n\n      val remaining = potential -- connections(pivot)\n\n      remaining.foldLeft(Set.empty[String]) { (currentMax, vertex) =>\n        val neighbors = connections(vertex)\n        val newClique = bronKerbosch(\n          result = result + vertex,\n          potential = potential & neighbors,\n          excluded = excluded & neighbors,\n        )\n        if (newClique.size > currentMax.size) newClique else currentMax\n      }\n\n  bronKerbosch(potential = connections.keySet)\n')),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D23T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/advent-of-code/blob/main/src/main/scala/year2024/day23.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day23.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day23/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2024/day23.html"},"Writeup")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day23.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day23"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);