"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7010],{2772:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>u});var n=a(7462),i=(a(7294),a(3905));a(6340);const o={},l="Day 7: Bridge Repair",r={unversionedId:"2024/puzzles/day07",id:"2024/puzzles/day07",title:"Day 7: Bridge Repair",description:"by @philippus",source:"@site/target/mdoc/2024/puzzles/day07.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day07",permalink:"/scala-advent-of-code/2024/puzzles/day07",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day07.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 6: Guard Gallivant",permalink:"/scala-advent-of-code/2024/puzzles/day06"},next:{title:"Day 8: Resonant Collinearity",permalink:"/scala-advent-of-code/2024/puzzles/day08"}},s={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Parsing",id:"parsing",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],p={toc:u};function c(t){let{components:e,...a}=t;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-7-bridge-repair"},"Day 7: Bridge Repair"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/philippus"},"@philippus")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/7"},"https://adventofcode.com/2024/day/7")),(0,i.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Parse the input split the lines into the test value and the numbers on which we will operate"),(0,i.kt)("li",{parentName:"ol"},"Find the equations that can be made valid with the different operators (",(0,i.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"+")," and/or ",(0,i.kt)("inlineCode",{parentName:"li"},"||"),")."),(0,i.kt)("li",{parentName:"ol"},"Sum the test values of the equations that are possibly true")),(0,i.kt)("h3",{id:"parsing"},"Parsing"),(0,i.kt)("p",null,"Each line of the input contains a test value, followed by a colon and a space (",(0,i.kt)("inlineCode",{parentName:"p"},": "),") and a list of numbers seperated by\na space. Our parser iterates over the lines, extracts the test values and a list of numbers from each line.\nSince we will be summing potentially a lot of numbers, we use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Long")," and not an ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(input: String): Seq[(Long, List[Long])] =\n  input\n    .linesIterator\n    .map:\n      case s"$testValue: $numbers" => (testValue.toLong, numbers.split(" ").map(_.toLong).toList)\n    .toSeq\n')),(0,i.kt)("h3",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"To find the equations that could possibly be true we iterate over the equations and check each of them using a recursive\n",(0,i.kt)("inlineCode",{parentName:"p"},"checkEquation")," function. Its input is the test value and the list of numbers and its return value is a boolean.\nIn each iteration we have two choices, either we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator, or we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator.\nWe apply the operator on the first two numbers in the list, and then we call ",(0,i.kt)("inlineCode",{parentName:"p"},"checkEquation")," again with the result of the\noperation concatenated with the remaining numbers. So, the first number in the list serves as the accumulator."),(0,i.kt)("p",null,"If there is only one number left in the list we compare the value with the test value and if it is equal the equation\ncould be true."),(0,i.kt)("p",null,"Finally, we sum up the test values of all the equations that could be true."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def checkEquation(testValue: Long, numbers: List[Long]): Boolean =\n  numbers match {\n    case fst :: Nil         =>\n      fst == testValue\n    case fst :: snd :: rest =>\n      checkEquation(testValue, (fst * snd) :: rest) || checkEquation(testValue, (fst + snd) :: rest)\n  }\n\ndef part1(input: String): Long =\n  val equations = parse(input)\n  equations.map:\n    case (testValue, numbers) =>\n      if checkEquation(testValue, numbers) then testValue else 0L\n    .sum\nend part1\n")),(0,i.kt)("h3",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"In this part a new concatenation operator ",(0,i.kt)("inlineCode",{parentName:"p"},"||")," is added that combines the digits from its left and right inputs into a\nsingle number, for this we expand the ",(0,i.kt)("inlineCode",{parentName:"p"},"checkEquation")," function with a case that does exactly that. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," on\nthe two numbers, concatenate them using ",(0,i.kt)("inlineCode",{parentName:"p"},"++")," and then apply ",(0,i.kt)("inlineCode",{parentName:"p"},"toLong"),", concatenate with the remaining numbers and call\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"checkEquation")," function."),(0,i.kt)("p",null,"We add a ",(0,i.kt)("inlineCode",{parentName:"p"},"withConcat")," parameter to the ",(0,i.kt)("inlineCode",{parentName:"p"},"checkEquation")," function, so that we can use the same function for both parts 1\nand 2."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def checkEquation(testValue: Long, numbers: List[Long], withConcat: Boolean = false): Boolean =\n  numbers match {\n    case fst :: Nil         =>\n      fst == testValue\n    case fst :: snd :: rest =>\n      checkEquation(testValue, (fst * snd) :: rest, withConcat) || checkEquation(testValue, (fst + snd) :: rest, withConcat) ||\n        (withConcat && checkEquation(testValue, (fst.toString ++ snd.toString).toLong :: rest, withConcat))\n  }\n\ndef part2(input: String): Long =\n  val equations = parse(input)\n  equations.map:\n    case (testValue, numbers) =>\n      if checkEquation(testValue, numbers, withConcat = true) then testValue else 0L\n    .sum\nend part2\n")),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D7T2.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan/advent-of-code/blob/master/2024/src/main/scala/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/YannMoisan"},"YannMoisan")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/07/07.worksheet.sc#L82"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/"},"Spamegg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch/scala3-aoc-2024/blob/trunk/main/src/aoc2024/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rolandtritsch"},"Roland Tritsch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle/advent_of_code/blob/main/src/main/scala/aoc2024/day07/DaySeven.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/guycastle"},"Guillaume Vandecasteele")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day07/bridge-repair.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day7/src/main/scala/Solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Jannyboy11/AdventOfCode2024/blob/master/src/main/scala/day07/Day07.scala"},"Solution")," of ",(0,i.kt)("a",{parentName:"li",href:"https://x.com/JanBoerman95"},"Jan Boerman")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix/AdventOfCode2024/blob/main/src/main/scala/io/github/makingthematrix/AdventofCode2024/DaySeven.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/makingthematrix"},"Maciej Gorywoda")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi/advent-of-code-2024/blob/main/07/solution.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/nichobi"},"nichobi")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/profunctor-optics/advent-2024/blob/main/src/main/scala/advent2024/Day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/joroKr21"},"Georgi Krastev")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day7.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer/adventofcode2024/blob/e163baeaedcd90732b5e19f578a2faadeb1ef872/src/main/scala/day7.sc"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/itsjoeoui/aoc2024/blob/main/src/day07.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/itsjoeoui"},"itsjoeoui")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day7"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);